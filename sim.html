<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Controlled 3D Character Viewer (Local Models)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        #ai-status {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        #ai-thinking {
            font-style: italic;
            color: #aaffaa;
            margin-top: 5px;
        }
        #debug-info {
            margin-top: 10px;
            font-size: 12px;
            color: #aaaaaa;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 5px;
        }
        .progress-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.1s linear;
        }
        #environment-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 200px;
        }
        #model-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 4px;
            width: 100%;
            margin-top: 5px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h2>AI-Controlled Character</h2>
        <div id="ai-status">Initializing AI system...</div>
        <div class="progress-bar"><div id="action-progress" class="progress-fill"></div></div>
        <div id="ai-thinking"></div>
        <div id="debug-info"></div>
    </div>

    <div id="model-selector">
        <h2>Model Selection</h2>
        <select id="model-choice">
            <option value="mistral7b.gguf">Mistral 7B</option>
        </select>
        <button id="load-model-btn">Load Model</button>
        <div id="model-status">No model loaded</div>
    </div>

    <div id="environment-info">
        Environment: Grassy Field with Platform<br>
        Time: Day<br>
        Weather: Clear
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Python server endpoint for model inference
        const PYTHON_SERVER_URL = 'http://localhost:5000';

        // AI Movement Control with local model inference
// AI Movement Control with local model inference
async function getAIMovementInstructions(currentPosition, previousActions = [], hitWall = false) {
    try {
        const statusElement = document.getElementById('ai-thinking');
        statusElement.textContent = "AI is thinking about what to do next...";
        
        const modelChoice = document.getElementById('model-choice').value;
        
        // Send request to local Python server
        const response = await fetch(PYTHON_SERVER_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model_id: modelChoice,
                position: {
                    x: currentPosition.x,
                    y: currentPosition.y,
                    z: currentPosition.z
                },
                hit_wall: hitWall,
                previous_actions: previousActions.slice(-3),
                prompt: `You are an AI controlling a 3D character in a virtual environment with a grassy field and a wooden platform at (10, 0.5, 10). You decide what the character does next based on its current state and surroundings. The environment has walls at the boundaries (±50 on x and z axes).

The character is at position (${currentPosition.x.toFixed(1)}, ${currentPosition.y.toFixed(1)}, ${currentPosition.z.toFixed(1)}) in a grassy field with a wooden platform at (10, 0.5, 10). The environment has walls at x=±50 and z=±50.
${hitWall ? 'The character just hit a wall.' : ''}
                
Generate ONE natural, lifelike movement for the character to perform next. Return ONLY valid JSON with a single object containing:
- "action": one of [moveForward, moveBackward, moveLeft, moveRight, jump, sprint, idle, explore, lookAround]
- "duration": time in seconds (between 0.5 and 4)
- "thought": a brief description of the character's intention (like "Heading to the platform" or "Getting tired, need to rest")

Create an action that would make sense for a character exploring this environment, possibly interacting with the platform. Make the movement feel natural and purposeful. Avoid actions that would cause the character to hit walls or fall off edges.

Previous actions: ${JSON.stringify(previousActions.slice(-3))}`
            })
        });
        
        // Get the response data
        const data = await response.json();
        
        console.log('AI Response:', data);
        statusElement.textContent = "";
        
        // The server now returns the instruction directly as a JSON object
        // Wrap it in an array for compatibility with existing code
        return [data];
    } catch (error) {
        console.error('Error fetching AI instructions:', error);
        document.getElementById('ai-thinking').textContent = "AI connection error. Using fallback behavior.";
        
        return [
            { action: 'idle', duration: 2, thought: 'Taking in the surroundings' }
        ];
    }
}

        // Scene setup with enhanced environment
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.01);

        // Create grassy terrain
        const groundSize = 100;
        const groundSegments = 100;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, groundSegments, groundSegments);
        
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            vertices[i + 1] = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 0.5;
        }
        groundGeometry.computeVertexNormals();
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7cfc00,
            roughness: 0.8,
            metalness: 0.1,
            flatShading: false
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add wooden platform (new floor)
        const platformGeometry = new THREE.BoxGeometry(10, 0.5, 10);
        const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513, // Wood-like brown
            roughness: 0.7,
            metalness: 0.2
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.set(10, 0.25, 10); // Slightly above ground at x=10, z=10
        platform.castShadow = true;
        platform.receiveShadow = true;
        scene.add(platform);

        // Add main floor
        const floorGeometry = new THREE.BoxGeometry(100, 0.5, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555, // Dark gray
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.set(0, -0.25, 0); // Slightly below the terrain
        floor.receiveShadow = true;
        scene.add(floor);

        // Add border walls
        const wallHeight = 5;
        const wallThickness = 1;
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888, // Light gray
            roughness: 0.8,
            metalness: 0.2
        });

        // Define boundary limits for collision detection
        const boundaries = {
            minX: -49,
            maxX: 49,
            minZ: -49,
            maxZ: 49
        };

        // North wall
        const northWallGeometry = new THREE.BoxGeometry(100 + wallThickness*2, wallHeight, wallThickness);
        const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
        northWall.position.set(0, wallHeight/2, -50 - wallThickness/2);
        northWall.castShadow = true;
        northWall.receiveShadow = true;
        scene.add(northWall);

        // South wall
        const southWallGeometry = new THREE.BoxGeometry(100 + wallThickness*2, wallHeight, wallThickness);
        const southWall = new THREE.Mesh(southWallGeometry, wallMaterial);
        southWall.position.set(0, wallHeight/2, 50 + wallThickness/2);
        southWall.castShadow = true;
        southWall.receiveShadow = true;
        scene.add(southWall);

        // East wall
        const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
        const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
        eastWall.position.set(50 + wallThickness/2, wallHeight/2, 0);
        eastWall.castShadow = true;
        eastWall.receiveShadow = true;
        scene.add(eastWall);

        // West wall
        const westWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
        const westWall = new THREE.Mesh(westWallGeometry, wallMaterial);
        westWall.position.set(-50 - wallThickness/2, wallHeight/2, 0);
        westWall.castShadow = true;
        westWall.receiveShadow = true;
        scene.add(westWall);

        // Add environment objects (trees and rocks)
        function addEnvironmentObjects() {
            const treeGeometry = new THREE.ConeGeometry(1, 4, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d572c });
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            
            for (let i = 0; i < 20; i++) {
                const tree = new THREE.Group();
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.5;
                trunk.castShadow = true;
                tree.add(trunk);
                
                const leaves = new THREE.Mesh(treeGeometry, treeMaterial);
                leaves.position.y = 3;
                leaves.castShadow = true;
                tree.add(leaves);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 30;
                tree.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                scene.add(tree);
            }
            
            const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.9,
                metalness: 0.1
            });
            
            for (let i = 0; i < 15; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                const scale = 0.5 + Math.random() * 1.5;
                rock.scale.set(scale, scale * 0.7, scale);
                rock.rotation.y = Math.random() * Math.PI * 2;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 35;
                rock.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
            }
        }
        
        addEnvironmentObjects();

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -70;
        directionalLight.shadow.camera.right = 70;
        directionalLight.shadow.camera.top = 70;
        directionalLight.shadow.camera.bottom = -70;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x7cfc00, 0.3);
        scene.add(hemisphereLight);

        // Camera and renderer setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.minDistance = 5;
        orbitControls.maxDistance = 30;
        orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;
        orbitControls.enabled = false;

        // Character controller settings
        const characterControls = {
            moveSpeed: 0.1,
            sprintMultiplier: 2,
            jumpForce: 0.3,
            gravity: 0.01,
            airControl: 0.3,
            friction: 0.9,
            linearDamping: 0.95,
            groundDetectionRayLength: 1.5,
            groundOffset: 0.1,
            cameraHeight: 1.8,
            cameraDistance: 3,
            cameraSmoothing: 0.1,
            lookAtHeight: 1.0,
            rotationSpeed: 0.1,
            collisionRadius: 0.5  // Added for collision detection
        };

        // Character state
        const character = {
            model: null,
            mixer: null,
            animations: {},
            currentAnimation: null,
            position: new THREE.Vector3(0, 1, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: 0,
            targetRotation: 0,
            isGrounded: false,
            isMoving: false,
            isSprinting: false,
            isJumping: false,
            isLookingAround: false,
            previousState: null,
            isLoaded: false,
            actionHistory: []
        };

        // Camera state
        const cameraState = {
            mode: 'follow',
            rotation: { x: 0, y: 0 },
            targetRotation: { x: 0, y: 0 },
            fixedDistance: characterControls.cameraDistance,
            currentDistance: characterControls.cameraDistance,
            height: characterControls.cameraHeight,
            smoothFactor: 0.1,
            isLocked: false
        };

        // AI control state
        let aiInstructions = [];
        let currentInstructionIndex = 0;
        let instructionTimer = 0;
        let isLoadingInstructions = false;
        let sequenceCompleted = false;
        let lastThoughtChangeTime = 0;
        let currentThought = "";
        let modelLoaded = false;
        let hitWall = false;  // Track wall collisions

        // Model loading
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
        
        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        
        document.getElementById('debug-info').innerHTML = 'Loading model...';
        
        loader.load(
            'character.glb',
            async function (gltf) {
                character.model = gltf.scene;
                character.isLoaded = true;
                
                const box = new THREE.Box3().setFromObject(character.model);
                const center = box.getCenter(new THREE.Vector3());
                character.model.position.x = -center.x;
                character.model.position.z = -center.z;
                
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                if (maxDim > 2) {
                    const scale = 2 / maxDim;
                    character.model.scale.set(scale, scale, scale);
                }
                
                character.model.position.copy(character.position);
                
                character.model.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                scene.add(character.model);
                
                if (gltf.animations && gltf.animations.length) {
                    character.mixer = new THREE.AnimationMixer(character.model);
                    gltf.animations.forEach((clip) => {
                        const name = clip.name.toUpperCase();
                        character.animations[name] = character.mixer.clipAction(clip);
                        character.animations[name].setLoop(THREE.LoopRepeat);
                    });
                    
                    if (character.animations['IDLE']) {
                        character.animations['IDLE'].play();
                        character.currentAnimation = 'IDLE';
                    } else if (gltf.animations.length > 0) {
                        const firstAnim = gltf.animations[0].name.toUpperCase();
                        character.animations[firstAnim].play();
                        character.currentAnimation = firstAnim;
                    }
                }
                
                document.getElementById('debug-info').innerHTML = 'Model loaded successfully<br>Animations: ' + 
                    Object.keys(character.animations).join(', ');
                
                updateCameraPosition(true);
            },
            function (progress) {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                document.getElementById('debug-info').innerHTML = `Loading model: ${percent}%`;
            },
            function (error) {
                console.error('Error loading model:', error);
                document.getElementById('debug-info').innerHTML = 'Model loading error: ' + error.message;
            }
        );

        // Animation handling
        function setAnimation(animName) {
            if (!character.mixer || !character.animations[animName]) {
                return;
            }
            
            if (character.currentAnimation !== animName || 
                (animName === 'RUN' && character.previousState !== character.isSprinting)) {
                const prevAnim = character.animations[character.currentAnimation];
                const nextAnim = character.animations[animName];
                
                nextAnim.reset().fadeIn(0.2).play();
                nextAnim.timeScale = (animName === 'RUN' && character.isSprinting) ? 1.25 : 1;
                
                if (prevAnim && prevAnim !== nextAnim) {
                    prevAnim.fadeOut(0.2);
                }
                
                character.currentAnimation = animName;
                character.previousState = character.isSprinting;
            }
        }

        // Ground detection with multiple surfaces
        function checkGrounded() {
            const raycaster = new THREE.Raycaster(
                character.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
                new THREE.Vector3(0, -1, 0),
                0,
                characterControls.groundDetectionRayLength
            );
            const intersects = raycaster.intersectObjects([ground, platform, floor]);
            
            character.isGrounded = intersects.length > 0;
            if (character.isGrounded) {
                character.position.y = intersects[0].point.y + characterControls.groundOffset;
            }
            
            return character.isGrounded;
        }

        // Boundary collision detection
        function checkBoundaryCollision(newPosition) {
            // Check if the new position would be outside the boundaries
            if (newPosition.x < boundaries.minX || newPosition.x > boundaries.maxX ||
                newPosition.z < boundaries.minZ || newPosition.z > boundaries.maxZ) {
                return true; // Collision detected
            }
            return false; // No collision
        }

        // Camera positioning
        function updateCameraPosition(initial = false) {
            if (!character.model || !character.isLoaded) {
                return;
            }
            
            if (cameraState.mode === 'orbit') {
                orbitControls.target.copy(character.position.clone().add(new THREE.Vector3(0, characterControls.lookAtHeight, 0)));
                orbitControls.update();
                return;
            }
            
            const idealOffset = new THREE.Vector3(
                0,
                characterControls.cameraHeight,
                characterControls.cameraDistance
            );
            
            idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.rotation.y);
            idealOffset.add(character.position);
            
            if (initial) {
                camera.position.copy(idealOffset);
            } else {
                camera.position.lerp(idealOffset, characterControls.cameraSmoothing);
            }
            
            const lookAtPos = character.position.clone();
            lookAtPos.y += characterControls.lookAtHeight;
            
            camera.lookAt(lookAtPos);
            camera.rotateX(cameraState.rotation.x);
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Camera mode toggle
        window.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                cameraState.mode = cameraState.mode === 'follow' ? 'orbit' : 'follow';
                orbitControls.enabled = cameraState.mode === 'orbit';
                
                if (cameraState.mode === 'orbit') {
                    orbitControls.target.copy(character.position.clone().add(new THREE.Vector3(0, 1, 0)));
                }
            }
        });

        // Model loading button
        document.getElementById('load-model-btn').addEventListener('click', async () => {
            const modelChoice = document.getElementById('model-choice').value;
            const modelStatus = document.getElementById('model-status');
            const loadButton = document.getElementById('load-model-btn');
            
            loadButton.disabled = true;
            modelStatus.textContent = `Loading ${modelChoice}...`;
            
            try {
                // Send request to check if model is loaded
                const response = await fetch(`${PYTHON_SERVER_URL}/check-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: modelChoice
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    modelStatus.textContent = `Model ${modelChoice} loaded successfully`;
                    modelLoaded = true;
                    
                    // Start AI instructions once model is loaded
                    if (character.isLoaded && !isLoadingInstructions) {
                        isLoadingInstructions = true;
                        aiInstructions = await getAIMovementInstructions(character.position, character.actionHistory, hitWall);
                        isLoadingInstructions = false;
                    }
                } else {
                    modelStatus.textContent = `Error: ${data.error}`;
                }
            } catch (error) {
                modelStatus.textContent = `Connection error: ${error.message}`;
                console.error('Error checking model:', error);
            }
            
            loadButton.disabled = false;
        });

        // Animation loop
        const clock = new THREE.Clock();
        let lastTime = 0;
        
        async function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = clock.getElapsedTime();
            const delta = Math.min(currentTime - lastTime, 0.1);
            lastTime = currentTime;
            
            if (cameraState.mode === 'orbit') {
                orbitControls.update();
            }
            
            if (character.mixer) {
                character.mixer.update(delta);
            }
            
            if (!character.isLoaded || !modelLoaded || isLoadingInstructions) {
                renderer.render(scene, camera);
                return;
            }
            
            checkGrounded();
            
            if (!sequenceCompleted && aiInstructions.length > 0) {
                const currentInstruction = aiInstructions[currentInstructionIndex];
                
                if (!currentInstruction || !currentInstruction.action) {
                    instructionTimer = 0;
                    currentInstructionIndex++;
                    return;
                }
                
                instructionTimer += delta;
                
                const progressPercent = (instructionTimer / currentInstruction.duration) * 100;
                document.getElementById('action-progress').style.width = `${Math.min(progressPercent, 100)}%`;
                
                document.getElementById('ai-status').innerHTML = 
                    `<strong>Action:</strong> ${formatActionName(currentInstruction.action)}<br>` +
                    `<strong>Thought:</strong> ${currentInstruction.thought || "..."}<br>` +
                    `<strong>Progress:</strong> ${Math.min(Math.floor(progressPercent), 100)}%`;
                
                character.isMoving = false;
                character.isSprinting = false;
                character.isJumping = false;
                character.isLookingAround = false;
                character.velocity.x = 0;
                character.velocity.z = 0;
                
                // Calculate movement directions
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.rotation.y);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);
                right.normalize();
                
                let moveDirection = new THREE.Vector3();
                
                switch (currentInstruction.action.toLowerCase()) {
                    case 'moveforward':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        break;
                    case 'movebackward':
                        moveDirection.sub(forward);
                        character.isMoving = true;
                        break;
                    case 'moveleft':
                        moveDirection.add(right);
                        character.isMoving = true;
                        break;
                    case 'moveright':
                        moveDirection.sub(right);
                        character.isMoving = true;
                        break;
                    case 'sprint':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        character.isSprinting = true;
                        break;
                    case 'jump':
                        if (character.isGrounded) {
                            character.isJumping = true;
                            character.velocity.y = characterControls.jumpForce;
                        }
                        break;
                    case 'idle':
                        // No movement in idle state
                        break;
                    case 'lookaround':
                        character.isLookingAround = true;
                        // Rotate camera slightly for looking around effect
                        cameraState.rotation.y += Math.sin(currentTime * 0.5) * 0.01;
                        break;
                    case 'explore':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        // Occasionally change direction during exploration
                        if (Math.random() < 0.05) {
                            cameraState.rotation.y += (Math.random() - 0.5) * 0.1;
                        }
                        break;
                    default:
                        console.warn('Unknown action:', currentInstruction.action);
                }
                
                // Update character rotation to match movement direction
                if (character.isMoving && moveDirection.length() > 0) {
                    moveDirection.normalize();
                    character.rotation = Math.atan2(moveDirection.x, moveDirection.z);
                    character.model.rotation.y = character.rotation;
                }
                
                if (character.isMoving) {
                    const speed = characterControls.moveSpeed * 
                        (character.isSprinting ? characterControls.sprintMultiplier : 1) * 
                        (character.isGrounded ? 1 : characterControls.airControl);
                    
                    character.velocity.x = moveDirection.x * speed;
                    character.velocity.z = moveDirection.z * speed;
                } else {
                    character.velocity.x *= characterControls.friction;
                    character.velocity.z *= characterControls.friction;
                }
                
                // Apply gravity and ground constraints
                if (!character.isGrounded) {
                    character.velocity.y -= characterControls.gravity;
                } else if (!character.isJumping) {
                    character.velocity.y = 0;
                }
                
                // Set appropriate animation based on character state
                if (!character.isGrounded && character.velocity.y < 0) {
                    setAnimation('FALL');
                } else if (character.isJumping) {
                    setAnimation('JUMP');
                } else if (character.isMoving) {
                    if (character.isSprinting && character.animations['RUN']) {
                        setAnimation('RUN');
                    } else if (character.animations['WALK']) {
                        setAnimation('WALK');
                    } else if (character.animations['RUN']) {
                        setAnimation('RUN');
                    }
                } else if (character.isLookingAround && character.animations['IDLE_LOOK']) {
                    setAnimation('IDLE_LOOK');
                } else {
                    setAnimation('IDLE');
                }
                
                // Calculate new position with velocity
                const newPosition = character.position.clone().add(character.velocity);
                
                // Check for boundary collisions before applying movement
                if (!checkBoundaryCollision(newPosition)) {
                    // No collision, apply movement
                    character.position.copy(newPosition);
                    hitWall = false;
                } else {
                    // Collision detected, stop movement in that direction
                    // Allow sliding along walls by applying only valid components of velocity
                    hitWall = true;
                    
                    // Try moving only in X direction
                    const newPositionX = character.position.clone();
                    newPositionX.x += character.velocity.x;
                    
                    if (!checkBoundaryCollision(newPositionX)) {
                        character.position.x = newPositionX.x;
                    }
                    
                    // Try moving only in Z direction
                    const newPositionZ = character.position.clone();
                    newPositionZ.z += character.velocity.z;
                    
                    if (!checkBoundaryCollision(newPositionZ)) {
                        character.position.z = newPositionZ.z;
                    }
                    
                    // Reset velocity in directions that had collisions
                    if (character.position.x !== newPosition.x) {
                        character.velocity.x = 0;
                    }
                    if (character.position.z !== newPosition.z) {
                        character.velocity.z = 0;
                    }
                }
                
                // Update model position
                character.model.position.copy(character.position);
                
                // Check if current instruction is complete
                if (instructionTimer >= currentInstruction.duration) {
                    character.actionHistory.push({
                        action: currentInstruction.action,
                        thought: currentInstruction.thought,
                        position: {
                            x: character.position.x,
                            y: character.position.y,
                            z: character.position.z
                        }
                    });
                    
                    instructionTimer = 0;
                    currentInstructionIndex++;
                    
                    // Reset character state when instruction completes
                    character.isMoving = false;
                    character.isSprinting = false;
                    character.isJumping = false;
                    character.isLookingAround = false;
                    character.velocity.x = 0;
                    character.velocity.z = 0;
                    
                    // Force idle animation between instructions
                    setAnimation('IDLE');
                    
                    // Get new instruction when current one is complete
                    if (currentInstructionIndex >= aiInstructions.length) {
                        isLoadingInstructions = true;
                        document.getElementById('ai-thinking').textContent = "Planning next action...";
                        
                        try {
                            // Get a single new instruction for more dynamic behavior
                            aiInstructions = await getAIMovementInstructions(
                                character.position, 
                                character.actionHistory,
                                hitWall
                            );
                            currentInstructionIndex = 0;
                            instructionTimer = 0;
                        } catch (error) {
                            console.error("Error getting new AI instructions:", error);
                            document.getElementById('ai-thinking').textContent = "Error planning. Using fallback behavior.";
                            aiInstructions = [
                                { action: 'idle', duration: 2, thought: 'Thinking what to do next' }
                            ];
                            currentInstructionIndex = 0;
                        }
                        
                        isLoadingInstructions = false;
                    }
                }
            }
            
            // Update camera position
            updateCameraPosition();
            
            renderer.render(scene, camera);
        }
        
        function formatActionName(action) {
            if (!action) return "Unknown";
            return action
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase());
        }
        
        animate();
    </script>
</body>
</html>
