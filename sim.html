<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Tag Game - LLM-Controlled Characters</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        #ai-status {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        #ai-thinking {
            font-style: italic;
            color: #aaffaa;
            margin-top: 5px;
        }
        #debug-info {
            margin-top: 10px;
            font-size: 12px;
            color: #aaaaaa;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 5px;
        }
        .progress-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.1s linear;
        }
        #environment-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 200px;
        }
        #model-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 4px;
            width: 100%;
            margin-top: 5px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #grid-info {
            position: absolute;
            top: 10px;
            left: 320px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #grid-content {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        #active-model {
            font-weight: bold;
            color: #4CAF50;
        }
        #game-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 24px;
            display: none;
        }
        #enemy-info-panel {
            position: absolute; 
            bottom: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 15px; 
            border-radius: 8px; 
            max-width: 300px; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #role-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        .chaser {
            color: #ff3333;
        }
        .runner {
            color: #33ff33;
        }
        .tag-counter {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h2>Blue Character (Player 1)</h2>
        <div id="ai-status">Initializing AI system...</div>
        <div class="progress-bar"><div id="action-progress" class="progress-fill"></div></div>
        <div id="ai-thinking"></div>
        <div id="debug-info"></div>
    </div>

    <div id="grid-info">
        <h2>Game Information</h2>
        <div id="grid-content">Waiting for movement...</div>
        <div id="active-model">Current Model: None</div>
    </div>

    <div id="model-selector">
        <h2>Model Selection</h2>
        <div>
            <label>Blue Character Model:</label>
            <select id="model-1-choice">
                <option value="mlx-community/Llama-3.2-1B-Instruct-4bit">Llama-3.2-1B</option>
                <option value="nidum/Nidum-Llama-3.2-3B-Uncensored-MLX-4bit">Nidum-Llama-3.2-3B</option>
                <option value="mlx-community/Mistral-7B-Instruct-v0.2-8-bit-mlx">Mistral-7B-Instruct</option>
            </select>
        </div>
        <div style="margin-top: 10px;">
            <label>Red Character Model:</label>
            <select id="model-2-choice">
                <option value="nidum/Nidum-Llama-3.2-3B-Uncensored-MLX-4bit">Nidum-Llama-3.2-3B</option>
                <option value="mlx-community/Llama-3.2-1B-Instruct-4bit">Llama-3.2-1B</option>
                <option value="mlx-community/Mistral-7B-Instruct-v0.2-8-bit-mlx">Mistral-7B-Instruct</option>
            </select>
        </div>
        <div style="margin-top: 10px;">
            <label>Initial Chaser:</label>
            <select id="initial-chaser">
                <option value="blue">Blue Character</option>
                <option value="red">Red Character</option>
            </select>
        </div>
        <button id="load-models-btn">Start Game</button>
        <div id="model-status">No models loaded</div>
    </div>
    
    <div id="enemy-info-panel">
        <h2>Red Character (Player 2)</h2>
        <div id="enemy-ai-status">Waiting for model...</div>
        <div class="progress-bar"><div id="enemy-action-progress" class="progress-fill"></div></div>
        <div id="enemy-ai-thinking"></div>
    </div>

    <div id="environment-info">
        Environment: Grassy Field with Platform<br>
        Game: Tag<br>
        Rules: Roles reverse when characters touch
    </div>

    <div id="role-indicator"></div>
    <div id="tag-counter" class="tag-counter">Tags: 0</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Python server endpoint for model inference
        const PYTHON_SERVER_URL = 'http://localhost:5000';

        // Grid size for position tracking (10x10 grid)
        const GRID_SIZE = 10;

        // Game state
        const gameState = {
            isActive: false,
            blueIsChaser: true, // Blue starts as chaser by default
            tagCount: 0,
            lastTagTime: 0,
            tagCooldown: 2, // 2 seconds cooldown between tags
            showingRoleChange: false
        };

        // Get current grid position from world coordinates
        function getGridPosition(position) {
            return {
                x: Math.floor(position.x / GRID_SIZE),
                z: Math.floor(position.z / GRID_SIZE)
            };
        }

        // AI Movement Control for blue character
        async function getBlueAIInstructions(currentPosition, previousActions = [], hitWall = false, redPosition = null) {
            try {
                const statusElement = document.getElementById('ai-thinking');
                statusElement.textContent = "Blue AI is thinking...";
                
                // Get the selected model
                const modelChoice = document.getElementById('model-1-choice').value;
                
                // Calculate distance to red character
                const distanceToRed = redPosition ? 
                    Math.sqrt(
                        Math.pow(currentPosition.x - redPosition.x, 2) + 
                        Math.pow(currentPosition.z - redPosition.z, 2)
                    ) : 999;
                
                // Calculate direction to red character
                const directionToRed = redPosition ? {
                    x: redPosition.x - currentPosition.x,
                    z: redPosition.z - currentPosition.z
                } : null;
                
                // Update active model display
                document.getElementById('active-model').textContent = 
                    `Blue Model: ${modelChoice.split('/').pop()}`;
                
                // Calculate current grid position
                const currentGrid = getGridPosition(currentPosition);
                
                // Calculate red grid position
                const redGrid = redPosition ? getGridPosition(redPosition) : { x: -999, z: -999 };
                
                // Update grid info display
                document.getElementById('grid-content').innerHTML = 
                    `Blue Grid: (${currentGrid.x}, ${currentGrid.z})<br>` +
                    `Red Grid: (${redGrid.x}, ${redGrid.z})<br>` +
                    `Distance: ${distanceToRed.toFixed(1)} units<br>` +
                    `Blue is ${gameState.blueIsChaser ? 'CHASER' : 'RUNNER'}`;
                
                // Send request to local Python server
                const response = await fetch(`${PYTHON_SERVER_URL}/tag-game`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: modelChoice,
                        position: {
                            x: currentPosition.x,
                            y: currentPosition.y,
                            z: currentPosition.z
                        },
                        current_grid: currentGrid,
                        hit_wall: hitWall,
                        previous_actions: previousActions.slice(-5),
                        opponent_position: redPosition || { x: 0, y: 0, z: 0 },
                        opponent_grid: redGrid,
                        distance_to_opponent: distanceToRed,
                        direction_to_opponent: directionToRed,
                        is_chaser: gameState.blueIsChaser,
                        tag_count: gameState.tagCount
                    })
                });
                
                const data = await response.json();
                let instructions;
                
                try {
                    // Parse the response
                    instructions = data.response;
                    
                    // If it's a string, try to parse it as JSON
                    if (typeof instructions === 'string') {
                        // Look for JSON pattern in the response
                        const jsonMatch = instructions.match(/(\{[\s\S]*\})/);
                        
                        if (jsonMatch) {
                            instructions = JSON.parse(jsonMatch[0]);
                        } else {
                            // If no JSON pattern found, try parsing the whole content
                            instructions = JSON.parse(instructions);
                        }
                    }
                    
                    // If it's an array, take just the first item
                    if (Array.isArray(instructions)) {
                        instructions = instructions[0];
                    }
                    
                    // Wrap in array for compatibility with existing code
                    instructions = [instructions];
                } catch (parseError) {
                    console.error('Parse error for blue AI:', parseError);
                    console.log('Raw response:', data.response);
                    
                    // Fallback to a simple instruction if parsing fails
                    instructions = [
                        { action: 'idle', duration: 2, thought: 'Recovering from confusion' }
                    ];
                }
                
                console.log('Blue AI Instructions:', instructions);
                statusElement.textContent = "";
                return instructions;
            } catch (error) {
                console.error('Error fetching blue AI instructions:', error);
                document.getElementById('ai-thinking').textContent = "AI connection error. Using fallback behavior.";
                
                return [
                    { action: 'idle', duration: 2, thought: 'Taking in the surroundings' }
                ];
            }
        }

        // AI Movement Control for red character
        async function getRedAIInstructions(currentPosition, previousActions = [], hitWall = false, bluePosition = null) {
            try {
                const statusElement = document.getElementById('enemy-ai-thinking');
                statusElement.textContent = "Red AI is thinking...";
                
                // Get the selected model
                const modelChoice = document.getElementById('model-2-choice').value;
                
                // Calculate distance to blue character
                const distanceToBlue = bluePosition ? 
                    Math.sqrt(
                        Math.pow(currentPosition.x - bluePosition.x, 2) + 
                        Math.pow(currentPosition.z - bluePosition.z, 2)
                    ) : 999;
                
                // Calculate direction to blue character
                const directionToBlue = bluePosition ? {
                    x: bluePosition.x - currentPosition.x,
                    z: bluePosition.z - currentPosition.z
                } : null;
                
                // Calculate current grid position
                const currentGrid = getGridPosition(currentPosition);
                
                // Calculate blue grid position
                const blueGrid = bluePosition ? getGridPosition(bluePosition) : { x: -999, z: -999 };
                
                // Send request to local Python server
                const response = await fetch(`${PYTHON_SERVER_URL}/tag-game`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: modelChoice,
                        position: {
                            x: currentPosition.x,
                            y: currentPosition.y,
                            z: currentPosition.z
                        },
                        current_grid: currentGrid,
                        hit_wall: hitWall,
                        previous_actions: previousActions.slice(-5),
                        opponent_position: bluePosition || { x: 0, y: 0, z: 0 },
                        opponent_grid: blueGrid,
                        distance_to_opponent: distanceToBlue,
                        direction_to_opponent: directionToBlue,
                        is_chaser: !gameState.blueIsChaser, // Red is chaser when blue is not
                        tag_count: gameState.tagCount
                    })
                });
                
                const data = await response.json();
                let instructions;
                
                try {
                    // Parse the response
                    instructions = data.response;
                    
                    // If it's a string, try to parse it as JSON
                    if (typeof instructions === 'string') {
                        // Look for JSON pattern in the response
                        const jsonMatch = instructions.match(/(\{[\s\S]*\})/);
                        
                        if (jsonMatch) {
                            instructions = JSON.parse(jsonMatch[0]);
                        } else {
                            // If no JSON pattern found, try parsing the whole content
                            instructions = JSON.parse(instructions);
                        }
                    }
                    
                    // If it's an array, take just the first item
                    if (Array.isArray(instructions)) {
                        instructions = instructions[0];
                    }
                    
                    // Wrap in array for compatibility with existing code
                    instructions = [instructions];
                } catch (parseError) {
                    console.error('Parse error for red AI:', parseError);
                    console.log('Raw response:', data.response);
                    
                    // Fallback to a simple instruction if parsing fails
                    instructions = [
                        { action: 'idle', duration: 2, thought: 'Recovering from confusion' }
                    ];
                }
                
                console.log('Red AI Instructions:', instructions);
                statusElement.textContent = "";
                return instructions;
            } catch (error) {
                console.error('Error fetching red AI instructions:', error);
                document.getElementById('enemy-ai-thinking').textContent = "AI connection error. Using fallback behavior.";
                
                return [
                    { action: 'idle', duration: 2, thought: 'Taking in the surroundings' }
                ];
            }
        }

        // Scene setup with enhanced environment
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.01);

        // Create grassy terrain
        const groundSize = 100;
        const groundSegments = 100;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, groundSegments, groundSegments);
        
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            vertices[i + 1] = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 0.5;
        }
        groundGeometry.computeVertexNormals();
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7cfc00,
            roughness: 0.8,
            metalness: 0.1,
            flatShading: false
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add wooden platform (new floor)
        const platformGeometry = new THREE.BoxGeometry(10, 0.5, 10);
        const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513, // Wood-like brown
            roughness: 0.7,
            metalness: 0.2
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.set(10, 0.25, 10); // Slightly above ground at x=10, z=10
        platform.castShadow = true;
        platform.receiveShadow = true;
        scene.add(platform);

        // Add main floor
        const floorGeometry = new THREE.BoxGeometry(100, 0.5, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555, // Dark gray
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.set(0, -0.25, 0); // Slightly below the terrain
        floor.receiveShadow = true;
        scene.add(floor);

        // Add border walls
        const wallHeight = 5;
        const wallThickness = 1;
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888, // Light gray
            roughness: 0.8,
            metalness: 0.2
        });

        // Define boundary limits for collision detection
        const boundaries = {
            minX: -49,
            maxX: 49,
            minZ: -49,
            maxZ: 49
        };

        // North wall
        const northWallGeometry = new THREE.BoxGeometry(100 + wallThickness*2, wallHeight, wallThickness);
        const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
        northWall.position.set(0, wallHeight/2, -50 - wallThickness/2);
        northWall.castShadow = true;
        northWall.receiveShadow = true;
        scene.add(northWall);

        // South wall
        const southWallGeometry = new THREE.BoxGeometry(100 + wallThickness*2, wallHeight, wallThickness);
        const southWall = new THREE.Mesh(southWallGeometry, wallMaterial);
        southWall.position.set(0, wallHeight/2, 50 + wallThickness/2);
        southWall.castShadow = true;
        southWall.receiveShadow = true;
        scene.add(southWall);

        // East wall
        const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
        const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
        eastWall.position.set(50 + wallThickness/2, wallHeight/2, 0);
        eastWall.castShadow = true;
        eastWall.receiveShadow = true;
        scene.add(eastWall);

        // West wall
        const westWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
        const westWall = new THREE.Mesh(westWallGeometry, wallMaterial);
        westWall.position.set(-50 - wallThickness/2, wallHeight/2, 0);
        westWall.castShadow = true;
        westWall.receiveShadow = true;
        scene.add(westWall);

        // Add grid markers to visualize the grid
        function addGridMarkers() {
            const gridLineGeometry = new THREE.BoxGeometry(0.1, 0.1, 100);
            const gridLineMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
            
            // Add grid lines along X axis
            for (let i = -5; i <= 5; i++) {
                const xLine = new THREE.Mesh(gridLineGeometry, gridLineMaterial);
                xLine.position.set(i * GRID_SIZE, 0.05, 0);
                scene.add(xLine);
            }
            
            // Add grid lines along Z axis
            const gridLineGeometryX = new THREE.BoxGeometry(100, 0.1, 0.1);
            for (let i = -5; i <= 5; i++) {
                const zLine = new THREE.Mesh(gridLineGeometryX, gridLineMaterial);
                zLine.position.set(0, 0.05, i * GRID_SIZE);
                scene.add(zLine);
            }
            
            // Add grid cell markers
            const markerGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
            
            for (let x = -5; x <= 5; x++) {
                for (let z = -5; z <= 5; z++) {
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.set(x * GRID_SIZE, 0.1, z * GRID_SIZE);
                    scene.add(marker);
                }
            }
        }
        
        addGridMarkers();

        // Add environment objects (trees and rocks)
        function addEnvironmentObjects() {
            const treeGeometry = new THREE.ConeGeometry(1, 4, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d572c });
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            
            for (let i = 0; i < 20; i++) {
                const tree = new THREE.Group();
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.5;
                trunk.castShadow = true;
                tree.add(trunk);
                
                const leaves = new THREE.Mesh(treeGeometry, treeMaterial);
                leaves.position.y = 3;
                leaves.castShadow = true;
                tree.add(leaves);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 30;
                tree.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                scene.add(tree);
            }
            
            const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.9,
                metalness: 0.1
            });
            
            for (let i = 0; i < 15; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                const scale = 0.5 + Math.random() * 1.5;
                rock.scale.set(scale, scale * 0.7, scale);
                rock.rotation.y = Math.random() * Math.PI * 2;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 35;
                rock.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
            }
        }
        
        addEnvironmentObjects();

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -70;
        directionalLight.shadow.camera.right = 70;
        directionalLight.shadow.camera.top = 70;
        directionalLight.shadow.camera.bottom = -70;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x7cfc00, 0.3);
        scene.add(hemisphereLight);

        // Camera and renderer setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.minDistance = 5;
        orbitControls.maxDistance = 50;
        orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;
        orbitControls.enabled = true;

        // Character controller settings
        const characterControls = {
            moveSpeed: 0.1,
            sprintMultiplier: 2,
            jumpForce: 0.3,
            gravity: 0.01,
            airControl: 0.3,
            friction: 0.9,
            linearDamping: 0.95,
            groundDetectionRayLength: 1.5,
            groundOffset: 0.1,
            cameraHeight: 1.8,
            cameraDistance: 3,
            cameraSmoothing: 0.1,
            lookAtHeight: 1.0,
            rotationSpeed: 0.1,
            collisionRadius: 0.5,  // Added for collision detection
            diagonalSpeedMultiplier: 0.7 // Reduce diagonal movement speed to avoid being too fast
        };

        // Blue character state
        const blueCharacter = {
            model: null,
            mixer: null,
            animations: {},
            currentAnimation: null,
            position: new THREE.Vector3(-20, 1, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: 0,
            targetRotation: 0,
            isGrounded: false,
            isMoving: false,
            isSprinting: false,
            isJumping: false,
            isLookingAround: false,
            previousState: null,
            isLoaded: false,
            actionHistory: []
        };

        // Red character state
        const redCharacter = {
            model: null,
            mixer: null,
            animations: {},
            currentAnimation: null,
            position: new THREE.Vector3(20, 1, 0), // Start red character on opposite side
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: 0,
            targetRotation: 0,
            isGrounded: false,
            isMoving: false,
            isSprinting: false,
            isJumping: false,
            isLookingAround: false,
            previousState: null,
            isLoaded: false,
            actionHistory: []
        };

        // AI control state
        let blueAIInstructions = [];
        let blueInstructionIndex = 0;
        let blueInstructionTimer = 0;
        let isLoadingBlueInstructions = false;
        
        let redAIInstructions = [];
        let redInstructionIndex = 0;
        let redInstructionTimer = 0;
        let isLoadingRedInstructions = false;
        
        let blueModelLoaded = false;
        let redModelLoaded = false;
        let blueHitWall = false;
        let redHitWall = false;

        // Model loading
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
        
        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        
        document.getElementById('debug-info').innerHTML = 'Loading character models...';
        
        // Load blue character
        loader.load(
            'character.glb',
            function (gltf) {
                blueCharacter.model = gltf.scene;
                blueCharacter.isLoaded = true;
                
                const box = new THREE.Box3().setFromObject(blueCharacter.model);
                const center = box.getCenter(new THREE.Vector3());
                blueCharacter.model.position.x = -center.x;
                blueCharacter.model.position.z = -center.z;
                
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                if (maxDim > 2) {
                    const scale = 2 / maxDim;
                    blueCharacter.model.scale.set(scale, scale, scale);
                }
                
                blueCharacter.model.position.copy(blueCharacter.position);
                
                blueCharacter.model.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        
                        // Set blue material
                        const blueMaterial = new THREE.MeshStandardMaterial({
                            color: 0x0066ff,
                            roughness: 0.7,
                            metalness: 0.3
                        });
                        node.material = blueMaterial;
                    }
                });
                
                scene.add(blueCharacter.model);
                
                if (gltf.animations && gltf.animations.length) {
                    blueCharacter.mixer = new THREE.AnimationMixer(blueCharacter.model);
                    gltf.animations.forEach((clip) => {
                        const name = clip.name.toUpperCase();
                        blueCharacter.animations[name] = blueCharacter.mixer.clipAction(clip);
                        blueCharacter.animations[name].setLoop(THREE.LoopRepeat);
                    });
                    
                    if (blueCharacter.animations['IDLE']) {
                        blueCharacter.animations['IDLE'].play();
                        blueCharacter.currentAnimation = 'IDLE';
                    } else if (gltf.animations.length > 0) {
                        const firstAnim = gltf.animations[0].name.toUpperCase();
                        blueCharacter.animations[firstAnim].play();
                        blueCharacter.currentAnimation = firstAnim;
                    }
                }
                
                document.getElementById('debug-info').innerHTML = 'Blue character loaded. Loading red character...';
                
                // Now load the red character (same model but with red material)
                loader.load(
                    'character.glb',
                    function (redGltf) {
                        redCharacter.model = redGltf.scene;
                        redCharacter.isLoaded = true;
                        
                        // Center the model
                        const redBox = new THREE.Box3().setFromObject(redCharacter.model);
                        const redCenter = redBox.getCenter(new THREE.Vector3());
                        redCharacter.model.position.x = -redCenter.x;
                        redCharacter.model.position.z = -redCenter.z;
                        
                        // Scale if needed
                        const redSize = redBox.getSize(new THREE.Vector3());
                        const redMaxDim = Math.max(redSize.x, redSize.y, redSize.z);
                        if (redMaxDim > 2) {
                            const redScale = 2 / redMaxDim;
                            redCharacter.model.scale.set(redScale, redScale, redScale);
                        }
                        
                        // Set position
                        redCharacter.model.position.copy(redCharacter.position);
                      
                        redCharacter.model.traverse(function(node) {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                                
                                // Set red material
                                const redMaterial = new THREE.MeshStandardMaterial({
                                    color: 0xff3333,
                                    roughness: 0.7,
                                    metalness: 0.3
                                });
                                
                                node.material = redMaterial;
                            }
                        });
                        
                        scene.add(redCharacter.model);
                        
                        // Set up red character animations
                        if (redGltf.animations && redGltf.animations.length) {
                            redCharacter.mixer = new THREE.AnimationMixer(redCharacter.model);
                            redGltf.animations.forEach((clip) => {
                                const name = clip.name.toUpperCase();
                                redCharacter.animations[name] = redCharacter.mixer.clipAction(clip);
                                redCharacter.animations[name].setLoop(THREE.LoopRepeat);
                            });
                            
                            if (redCharacter.animations['IDLE']) {
                                redCharacter.animations['IDLE'].play();
                                redCharacter.currentAnimation = 'IDLE';
                            } else if (redGltf.animations.length > 0) {
                                const firstAnim = redGltf.animations[0].name.toUpperCase();
                                redCharacter.animations[firstAnim].play();
                                redCharacter.currentAnimation = firstAnim;
                            }
                        }
                        
                        document.getElementById('debug-info').innerHTML = 'All models loaded successfully';
                    },
                    function (progress) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        document.getElementById('debug-info').innerHTML = `Loading red character: ${percent}%`;
                    },
                    function (error) {
                        console.error('Error loading red character:', error);
                        document.getElementById('debug-info').innerHTML = 'Red character loading error: ' + error.message;
                    }
                );
            },
            function (progress) {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                document.getElementById('debug-info').innerHTML = `Loading blue character: ${percent}%`;
            },
            function (error) {
                console.error('Error loading blue character:', error);
                document.getElementById('debug-info').innerHTML = 'Blue character loading error: ' + error.message;
            }
        );

        // Animation handling for blue character
        function setBlueAnimation(animName) {
            if (!blueCharacter.mixer || !blueCharacter.animations[animName]) {
                return;
            }
            
            if (blueCharacter.currentAnimation !== animName || 
                (animName === 'RUN' && blueCharacter.previousState !== blueCharacter.isSprinting)) {
                const prevAnim = blueCharacter.animations[blueCharacter.currentAnimation];
                const nextAnim = blueCharacter.animations[animName];
                
                nextAnim.reset().fadeIn(0.2).play();
                nextAnim.timeScale = (animName === 'RUN' && blueCharacter.isSprinting) ? 1.25 : 1;
                
                if (prevAnim && prevAnim !== nextAnim) {
                    prevAnim.fadeOut(0.2);
                }
                
                blueCharacter.currentAnimation = animName;
                blueCharacter.previousState = blueCharacter.isSprinting;
            }
        }

        // Animation handling for red character
        function setRedAnimation(animName) {
            if (!redCharacter.mixer || !redCharacter.animations[animName]) {
                return;
            }
            
            if (redCharacter.currentAnimation !== animName || 
                (animName === 'RUN' && redCharacter.previousState !== redCharacter.isSprinting)) {
                const prevAnim = redCharacter.animations[redCharacter.currentAnimation];
                const nextAnim = redCharacter.animations[animName];
                
                nextAnim.reset().fadeIn(0.2).play();
                nextAnim.timeScale = (animName === 'RUN' && redCharacter.isSprinting) ? 1.25 : 1;
                
                if (prevAnim && prevAnim !== nextAnim) {
                    prevAnim.fadeOut(0.2);
                }
                
                redCharacter.currentAnimation = animName;
                redCharacter.previousState = redCharacter.isSprinting;
            }
        }

        // Ground detection with multiple surfaces
        function checkGrounded(entity) {
            const raycaster = new THREE.Raycaster(
                entity.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
                new THREE.Vector3(0, -1, 0),
                0,
                characterControls.groundDetectionRayLength
            );
            const intersects = raycaster.intersectObjects([ground, platform, floor]);
            
            entity.isGrounded = intersects.length > 0;
            if (entity.isGrounded) {
                entity.position.y = intersects[0].point.y + characterControls.groundOffset;
            }
            
            return entity.isGrounded;
        }

        // Boundary collision detection
        function checkBoundaryCollision(newPosition) {
            // Check if the new position would be outside the boundaries
            if (newPosition.x < boundaries.minX || newPosition.x > boundaries.maxX ||
                newPosition.z < boundaries.minZ || newPosition.z > boundaries.maxZ) {
                return true; // Collision detected
            }
            return false; // No collision
        }

        // Check if characters are close enough for a tag
        function checkTagCollision() {
            if (!blueCharacter.isLoaded || !redCharacter.isLoaded || !gameState.isActive) return false;
            
            const distance = blueCharacter.position.distanceTo(redCharacter.position);
            const currentTime = performance.now() / 1000; // Convert to seconds
            
            // Only allow tagging if cooldown has passed
            if (distance <= characterControls.collisionRadius * 2 && 
                currentTime - gameState.lastTagTime > gameState.tagCooldown) {
                return true;
            }
            
            return false;
        }

        // Handle tag event
        function handleTag() {
            // Increment tag count
            gameState.tagCount++;
            document.getElementById('tag-counter').textContent = `Tags: ${gameState.tagCount}`;
            
            // Swap roles
            gameState.blueIsChaser = !gameState.blueIsChaser;
            
            // Update last tag time
            gameState.lastTagTime = performance.now() / 1000;
            
            // Show role change indicator
            const roleIndicator = document.getElementById('role-indicator');
            if (gameState.blueIsChaser) {
                roleIndicator.innerHTML = `<span class="chaser">Blue is now CHASER!</span><br><span class="runner">Red is now RUNNER!</span>`;
            } else {
                roleIndicator.innerHTML = `<span class="chaser">Red is now CHASER!</span><br><span class="runner">Blue is now RUNNER!</span>`;
            }
            
            roleIndicator.style.opacity = 1;
            gameState.showingRoleChange = true;
            
            // Hide role indicator after 2 seconds
            setTimeout(() => {
                roleIndicator.style.opacity = 0;
                gameState.showingRoleChange = false;
            }, 2000);
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Model loading button
        document.getElementById('load-models-btn').addEventListener('click', async () => {
            const blueModelChoice = document.getElementById('model-1-choice').value;
            const redModelChoice = document.getElementById('model-2-choice').value;
            const initialChaser = document.getElementById('initial-chaser').value;
            const modelStatus = document.getElementById('model-status');
            const loadButton = document.getElementById('load-models-btn');
            
            // Set initial chaser based on selection
            gameState.blueIsChaser = initialChaser === 'blue';
            
            loadButton.disabled = true;
            modelStatus.textContent = `Loading models...`;
            
            try {
                // Check blue model
                const blueModelResponse = await fetch(`${PYTHON_SERVER_URL}/check-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: blueModelChoice
                    })
                });
                
                const blueModelData = await blueModelResponse.json();
                
                if (blueModelData.success) {
                    modelStatus.textContent = `Blue model loaded. Loading Red model...`;
                    blueModelLoaded = true;
                } else {
                    modelStatus.textContent = `Error loading Blue model: ${blueModelData.error}`;
                    loadButton.disabled = false;
                    return;
                }
                
                // Check red model
                const redModelResponse = await fetch(`${PYTHON_SERVER_URL}/check-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: redModelChoice
                    })
                });
                
                const redModelData = await redModelResponse.json();
                
                if (redModelData.success) {
                    modelStatus.textContent = `Both models loaded successfully`;
                    redModelLoaded = true;
                    
                    // Start the game
                    gameState.isActive = true;
                    
                    // Show initial roles
                    const roleIndicator = document.getElementById('role-indicator');
                    if (gameState.blueIsChaser) {
                        roleIndicator.innerHTML = `<span class="chaser">Blue is CHASER!</span><br><span class="runner">Red is RUNNER!</span>`;
                    } else {
                        roleIndicator.innerHTML = `<span class="chaser">Red is CHASER!</span><br><span class="runner">Blue is RUNNER!</span>`;
                    }
                    
                    roleIndicator.style.opacity = 1;
                    gameState.showingRoleChange = true;
                    
                    // Hide role indicator after 3 seconds
                    setTimeout(() => {
                        roleIndicator.style.opacity = 0;
                        gameState.showingRoleChange = false;
                    }, 3000);
                    
                    // Get initial instructions for both characters
                    if (blueCharacter.isLoaded && !isLoadingBlueInstructions) {
                        isLoadingBlueInstructions = true;
                        blueAIInstructions = await getBlueAIInstructions(
                            blueCharacter.position, 
                            blueCharacter.actionHistory, 
                            blueHitWall,
                            redCharacter.position
                        );
                        isLoadingBlueInstructions = false;
                    }
                    
                    if (redCharacter.isLoaded && !isLoadingRedInstructions) {
                        isLoadingRedInstructions = true;
                        redAIInstructions = await getRedAIInstructions(
                            redCharacter.position, 
                            redCharacter.actionHistory, 
                            redHitWall,
                            blueCharacter.position
                        );
                        isLoadingRedInstructions = false;
                    }
                } else {
                    modelStatus.textContent = `Error loading Red model: ${redModelData.error}`;
                }
            } catch (error) {
                modelStatus.textContent = `Connection error: ${error.message}`;
                console.error('Error checking models:', error);
            }
            
            loadButton.disabled = false;
        });

        // Process blue character movement based on AI instructions
        function processBlueCharacterMovement(delta) {
            if (!blueCharacter.isLoaded || !blueModelLoaded || isLoadingBlueInstructions || !gameState.isActive) {
                return;
            }
            
            checkGrounded(blueCharacter);
            
            if (blueAIInstructions.length > 0) {
                const currentInstruction = blueAIInstructions[blueInstructionIndex];
                
                if (!currentInstruction || !currentInstruction.action) {
                    blueInstructionTimer = 0;
                    blueInstructionIndex++;
                    return;
                }
                
                blueInstructionTimer += delta;
                
                const progressPercent = (blueInstructionTimer / currentInstruction.duration) * 100;
                document.getElementById('action-progress').style.width = `${Math.min(progressPercent, 100)}%`;
                
                document.getElementById('ai-status').innerHTML = 
                    `<strong>Action:</strong> ${formatActionName(currentInstruction.action)}<br>` +
                    `<strong>Thought:</strong> ${currentInstruction.thought || "..."}<br>` +
                    `<strong>Progress:</strong> ${Math.min(Math.floor(progressPercent), 100)}%<br>` +
                    `<strong>Role:</strong> ${gameState.blueIsChaser ? '<span class="chaser">CHASER</span>' : '<span class="runner">RUNNER</span>'}`;
                
                blueCharacter.isMoving = false;
                blueCharacter.isSprinting = false;
                blueCharacter.isJumping = false;
                blueCharacter.isLookingAround = false;
                blueCharacter.velocity.x = 0;
                blueCharacter.velocity.z = 0;
                
                // Calculate movement directions
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);
                right.normalize();
                
                let moveDirection = new THREE.Vector3();
                
                switch (currentInstruction.action.toLowerCase()) {
                    case 'moveforward':
                        moveDirection.add(forward);
                        blueCharacter.isMoving = true;
                        break;
                    case 'movebackward':
                        moveDirection.sub(forward);
                        blueCharacter.isMoving = true;
                        break;
                    case 'moveleft':
                        moveDirection.sub(right);
                        blueCharacter.isMoving = true;
                        break;
                    case 'moveright':
                        moveDirection.add(right);
                        blueCharacter.isMoving = true;
                        break;
                    case 'movediagonalforwardleft':
                        moveDirection.add(forward).sub(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        blueCharacter.isMoving = true;
                        break;
                    case 'movediagonalforwardright':
                        moveDirection.add(forward).add(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        blueCharacter.isMoving = true;
                        break;
                    case 'movediagonalbackwardleft':
                        moveDirection.sub(forward).sub(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        blueCharacter.isMoving = true;
                        break;
                    case 'movediagonalbackwardright':
                        moveDirection.sub(forward).add(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        blueCharacter.isMoving = true;
                        break;
                    case 'sprint':
                        moveDirection.add(forward);
                        blueCharacter.isMoving = true;
                        blueCharacter.isSprinting = true;
                        break;
                    case 'jump':
                        if (blueCharacter.isGrounded) {
                            blueCharacter.isJumping = true;
                            blueCharacter.velocity.y = characterControls.jumpForce;
                        }
                        break;
                    case 'idle':
                        // No movement in idle state
                        break;
                    case 'lookaround':
                        blueCharacter.isLookingAround = true;
                        break;
                    case 'explore':
                        moveDirection.add(forward);
                        blueCharacter.isMoving = true;
                        // Occasionally change direction during exploration
                        if (Math.random() < 0.05) {
                            blueCharacter.targetRotation += (Math.random() - 0.5) * 0.5;
                        }
                        break;
                    default:
                        console.warn('Unknown action for blue character:', currentInstruction.action);
                }
                
                // If we're chasing, try to move toward red character
                if (gameState.blueIsChaser && blueCharacter.isMoving) {
                    const directionToRed = new THREE.Vector3()
                        .subVectors(redCharacter.position, blueCharacter.position)
                        .normalize();
                    
                    // Blend between the AI direction and direction to red
                    moveDirection.lerp(directionToRed, 0.3);
                    moveDirection.normalize();
                    
                    // Update rotation to face movement direction
                    blueCharacter.targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
                }
                // If we're running away, try to move away from red character
                else if (!gameState.blueIsChaser && blueCharacter.isMoving) {
                    const directionFromRed = new THREE.Vector3()
                        .subVectors(blueCharacter.position, redCharacter.position)
                        .normalize();
                    
                    // Blend between the AI direction and direction away from red
                    moveDirection.lerp(directionFromRed, 0.3);
                    moveDirection.normalize();
                    
                    // Update rotation to face movement direction
                    blueCharacter.targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
                }
                
                // Smoothly rotate toward target rotation
                if (blueCharacter.rotation !== blueCharacter.targetRotation) {
                    const rotDiff = blueCharacter.targetRotation - blueCharacter.rotation;
                    
                    // Handle angle wrapping
                    let rotStep = rotDiff;
                    if (rotDiff > Math.PI) rotStep = rotDiff - Math.PI * 2;
                    if (rotDiff < -Math.PI) rotStep = rotDiff + Math.PI * 2;
                    
                    blueCharacter.rotation += rotStep * characterControls.rotationSpeed;
                    
                    // Keep rotation in range [-PI, PI]
                    if (blueCharacter.rotation > Math.PI) blueCharacter.rotation -= Math.PI * 2;
                    if (blueCharacter.rotation < -Math.PI) blueCharacter.rotation += Math.PI * 2;
                    
                    if (blueCharacter.model) {
                        blueCharacter.model.rotation.y = blueCharacter.rotation;
                    }
                }
                
                if (blueCharacter.isMoving) {
                    const speed = characterControls.moveSpeed * 
                        (blueCharacter.isSprinting ? characterControls.sprintMultiplier : 1) * 
                        (blueCharacter.isGrounded ? 1 : characterControls.airControl);
                    
                    // Rotate movement direction to match character rotation
                    const rotatedDirection = moveDirection.clone();
                    rotatedDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), blueCharacter.rotation);
                    
                    blueCharacter.velocity.x = rotatedDirection.x * speed;
                    blueCharacter.velocity.z = rotatedDirection.z * speed;
                } else {
                    blueCharacter.velocity.x *= characterControls.friction;
                    blueCharacter.velocity.z *= characterControls.friction;
                }
                
                // Apply gravity and ground constraints
                if (!blueCharacter.isGrounded) {
                    blueCharacter.velocity.y -= characterControls.gravity;
                } else if (!blueCharacter.isJumping) {
                    blueCharacter.velocity.y = 0;
                }
                
                // Set appropriate animation based on character state
                if (!blueCharacter.isGrounded && blueCharacter.velocity.y < 0) {
                    setBlueAnimation('FALL');
                } else if (blueCharacter.isJumping) {
                    setBlueAnimation('JUMP');
                } else if (blueCharacter.isMoving) {
                    if (blueCharacter.isSprinting && blueCharacter.animations['RUN']) {
                        setBlueAnimation('RUN');
                    } else if (blueCharacter.animations['WALK']) {
                        setBlueAnimation('WALK');
                    } else if (blueCharacter.animations['RUN']) {
                        setBlueAnimation('RUN');
                    }
                } else if (blueCharacter.isLookingAround && blueCharacter.animations['IDLE_LOOK']) {
                    setBlueAnimation('IDLE_LOOK');
                } else {
                    setBlueAnimation('IDLE');
                }
                
                // Calculate new position with velocity
                const newPosition = blueCharacter.position.clone().add(blueCharacter.velocity);
                
                // Check for boundary collisions before applying movement
                if (!checkBoundaryCollision(newPosition)) {
                    // No collision, apply movement
                    blueCharacter.position.copy(newPosition);
                    blueHitWall = false;
                } else {
                    // Collision detected, stop movement in that direction
                    blueHitWall = true;
                    
                    // Try moving only in X direction
                    const newPositionX = blueCharacter.position.clone();
                    newPositionX.x += blueCharacter.velocity.x;
                    
                    if (!checkBoundaryCollision(newPositionX)) {
                        blueCharacter.position.x = newPositionX.x;
                    }
                    
                    // Try moving only in Z direction
                    const newPositionZ = blueCharacter.position.clone();
                    newPositionZ.z += blueCharacter.velocity.z;
                    
                    if (!checkBoundaryCollision(newPositionZ)) {
                        blueCharacter.position.z = newPositionZ.z;
                    }
                    
                    // Reset velocity in directions that had collisions
                    if (blueCharacter.position.x !== newPosition.x) {
                        blueCharacter.velocity.x = 0;
                    }
                    if (blueCharacter.position.z !== newPosition.z) {
                        blueCharacter.velocity.z = 0;
                    }
                }
                
                // Update model position
                if (blueCharacter.model) {
                    blueCharacter.model.position.copy(blueCharacter.position);
                }
                
                // Check if current instruction is complete
                if (blueInstructionTimer >= currentInstruction.duration) {
                    blueCharacter.actionHistory.push({
                        action: currentInstruction.action,
                        thought: currentInstruction.thought,
                        position: {
                            x: blueCharacter.position.x,
                            y: blueCharacter.position.y,
                            z: blueCharacter.position.z
                        },
                        grid: getGridPosition(blueCharacter.position)
                    });
                    
                    blueInstructionTimer = 0;
                    blueInstructionIndex++;
                    
                    // Get new instruction when current one is complete
                    if (blueInstructionIndex >= blueAIInstructions.length) {
                        isLoadingBlueInstructions = true;
                        document.getElementById('ai-thinking').textContent = "Planning next action...";
                        
                        getBlueAIInstructions(
                            blueCharacter.position, 
                            blueCharacter.actionHistory,
                            blueHitWall,
                            redCharacter.position
                        ).then(instructions => {
                            blueAIInstructions = instructions;
                            blueInstructionIndex = 0;
                            blueInstructionTimer = 0;
                            isLoadingBlueInstructions = false;
                        }).catch(error => {
                            console.error("Error getting new blue AI instructions:", error);
                            isLoadingBlueInstructions = false;
                            document.getElementById('ai-thinking').textContent = "Error planning. Using fallback behavior.";
                            blueAIInstructions = [
                                { action: 'idle', duration: 2, thought: 'Thinking what to do next' }
                            ];
                            blueInstructionIndex = 0;
                        });
                    }
                }
            }
        }

        // Process red character movement based on AI instructions
        function processRedCharacterMovement(delta) {
            if (!redCharacter.isLoaded || !redModelLoaded || isLoadingRedInstructions || !gameState.isActive) {
                return;
            }
            
            checkGrounded(redCharacter);
            
            if (redAIInstructions.length > 0) {
                const currentInstruction = redAIInstructions[redInstructionIndex];
                
                if (!currentInstruction || !currentInstruction.action) {
                    redInstructionTimer = 0;
                    redInstructionIndex++;
                    return;
                }
                
                redInstructionTimer += delta;
                
                const progressPercent = (redInstructionTimer / currentInstruction.duration) * 100;
                document.getElementById('enemy-action-progress').style.width = `${Math.min(progressPercent, 100)}%`;
                
                document.getElementById('enemy-ai-status').innerHTML = 
                    `<strong>Action:</strong> ${formatActionName(currentInstruction.action)}<br>` +
                    `<strong>Thought:</strong> ${currentInstruction.thought || "..."}<br>` +
                    `<strong>Progress:</strong> ${Math.min(Math.floor(progressPercent), 100)}%<br>` +
                    `<strong>Role:</strong> ${!gameState.blueIsChaser ? '<span class="chaser">CHASER</span>' : '<span class="runner">RUNNER</span>'}`;
                
                redCharacter.isMoving = false;
                redCharacter.isSprinting = false;
                redCharacter.isJumping = false;
                redCharacter.isLookingAround = false;
                redCharacter.velocity.x = 0;
                redCharacter.velocity.z = 0;
                
                // Calculate movement directions
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);
                right.normalize();
                
                let moveDirection = new THREE.Vector3();
                
                switch (currentInstruction.action.toLowerCase()) {
                    case 'moveforward':
                        moveDirection.add(forward);
                        redCharacter.isMoving = true;
                        break;
                    case 'movebackward':
                        moveDirection.sub(forward);
                        redCharacter.isMoving = true;
                        break;
                    case 'moveleft':
                        moveDirection.sub(right);
                        redCharacter.isMoving = true;
                        break;
                    case 'moveright':
                        moveDirection.add(right);
                        redCharacter.isMoving = true;
                        break;
                    case 'movediagonalforwardleft':
                        moveDirection.add(forward).sub(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        redCharacter.isMoving = true;
                        break;
                    case 'movediagonalforwardright':
                        moveDirection.add(forward).add(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        redCharacter.isMoving = true;
                        break;
                    case 'movediagonalbackwardleft':
                        moveDirection.sub(forward).sub(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        redCharacter.isMoving = true;
                        break;
                    case 'movediagonalbackwardright':
                        moveDirection.sub(forward).add(right);
                        moveDirection.multiplyScalar(characterControls.diagonalSpeedMultiplier);
                        redCharacter.isMoving = true;
                        break;
                    case 'sprint':
                        moveDirection.add(forward);
                        redCharacter.isMoving = true;
                        redCharacter.isSprinting = true;
                        break;
                    case 'jump':
                        if (redCharacter.isGrounded) {
                            redCharacter.isJumping = true;
                            redCharacter.velocity.y = characterControls.jumpForce;
                        }
                        break;
                    case 'idle':
                        // No movement in idle state
                        break;
                    case 'lookaround':
                        redCharacter.isLookingAround = true;
                        break;
                    case 'explore':
                        moveDirection.add(forward);
                        redCharacter.isMoving = true;
                        // Occasionally change direction during exploration
                        if (Math.random() < 0.05) {
                            redCharacter.targetRotation += (Math.random() - 0.5) * 0.5;
                        }
                        break;
                    default:
                        console.warn('Unknown action for red character:', currentInstruction.action);
                }
                
                // If we're chasing, try to move toward blue character
                if (!gameState.blueIsChaser && redCharacter.isMoving) {
                    const directionToBlue = new THREE.Vector3()
                        .subVectors(blueCharacter.position, redCharacter.position)
                        .normalize();
                    
                    // Blend between the AI direction and direction to blue
                    moveDirection.lerp(directionToBlue, 0.3);
                    moveDirection.normalize();
                    
                    // Update rotation to face movement direction
                    redCharacter.targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
                }
                // If we're running away, try to move away from blue character
                else if (gameState.blueIsChaser && redCharacter.isMoving) {
                    const directionFromBlue = new THREE.Vector3()
                        .subVectors(redCharacter.position, blueCharacter.position)
                        .normalize();
                    
                    // Blend between the AI direction and direction away from blue
                    moveDirection.lerp(directionFromBlue, 0.3);
                    moveDirection.normalize();
                    
                    // Update rotation to face movement direction
                    redCharacter.targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
                }
                
                // Smoothly rotate toward target rotation
                if (redCharacter.rotation !== redCharacter.targetRotation) {
                    const rotDiff = redCharacter.targetRotation - redCharacter.rotation;
                    
                    // Handle angle wrapping
                    let rotStep = rotDiff;
                    if (rotDiff > Math.PI) rotStep = rotDiff - Math.PI * 2;
                    if (rotDiff < -Math.PI) rotStep = rotDiff + Math.PI * 2;
                    
                    redCharacter.rotation += rotStep * characterControls.rotationSpeed;
                    
                    // Keep rotation in range [-PI, PI]
                    if (redCharacter.rotation > Math.PI) redCharacter.rotation -= Math.PI * 2;
                    if (redCharacter.rotation < -Math.PI) redCharacter.rotation += Math.PI * 2;
                    
                    if (redCharacter.model) {
                        redCharacter.model.rotation.y = redCharacter.rotation;
                    }
                }
                
                if (redCharacter.isMoving) {
                    const speed = characterControls.moveSpeed * 
                        (redCharacter.isSprinting ? characterControls.sprintMultiplier : 1) * 
                        (redCharacter.isGrounded ? 1 : characterControls.airControl);
                    
                    // Rotate movement direction to match character rotation
                    const rotatedDirection = moveDirection.clone();
                    rotatedDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), redCharacter.rotation);
                    
                    redCharacter.velocity.x = rotatedDirection.x * speed;
                    redCharacter.velocity.z = rotatedDirection.z * speed;
                } else {
                    redCharacter.velocity.x *= characterControls.friction;
                    redCharacter.velocity.z *= characterControls.friction;
                }
                
                // Apply gravity and ground constraints
                if (!redCharacter.isGrounded) {
                    redCharacter.velocity.y -= characterControls.gravity;
                } else if (!redCharacter.isJumping) {
                    redCharacter.velocity.y = 0;
                }
                
                // Set appropriate animation based on character state
                if (!redCharacter.isGrounded && redCharacter.velocity.y < 0) {
                    setRedAnimation('FALL');
                } else if (redCharacter.isJumping) {
                    setRedAnimation('JUMP');
                } else if (redCharacter.isMoving) {
                    if (redCharacter.isSprinting && redCharacter.animations['RUN']) {
                        setRedAnimation('RUN');
                    } else if (redCharacter.animations['WALK']) {
                        setRedAnimation('WALK');
                    } else if (redCharacter.animations['RUN']) {
                        setRedAnimation('RUN');
                    }
                } else if (redCharacter.isLookingAround && redCharacter.animations['IDLE_LOOK']) {
                    setRedAnimation('IDLE_LOOK');
                } else {
                    setRedAnimation('IDLE');
                }
                
                // Calculate new position with velocity
                const newPosition = redCharacter.position.clone().add(redCharacter.velocity);
                
                // Check for boundary collisions before applying movement
                if (!checkBoundaryCollision(newPosition)) {
                    // No collision, apply movement
                    redCharacter.position.copy(newPosition);
                    redHitWall = false;
                } else {
                    // Collision detected, stop movement in that direction
                    redHitWall = true;
                    
                    // Try moving only in X direction
                    const newPositionX = redCharacter.position.clone();
                    newPositionX.x += redCharacter.velocity.x;
                    
                    if (!checkBoundaryCollision(newPositionX)) {
                        redCharacter.position.x = newPositionX.x;
                    }
                    
                    // Try moving only in Z direction
                    const newPositionZ = redCharacter.position.clone();
                    newPositionZ.z += redCharacter.velocity.z;
                    
                    if (!checkBoundaryCollision(newPositionZ)) {
                        redCharacter.position.z = newPositionZ.z;
                    }
                    
                    // Reset velocity in directions that had collisions
                    if (redCharacter.position.x !== newPosition.x) {
                        redCharacter.velocity.x = 0;
                    }
                    if (redCharacter.position.z !== newPosition.z) {
                        redCharacter.velocity.z = 0;
                    }
                }
                
                // Update model position
                if (redCharacter.model) {
                    redCharacter.model.position.copy(redCharacter.position);
                }
                
                // Check if current instruction is complete
                if (redInstructionTimer >= currentInstruction.duration) {
                    redCharacter.actionHistory.push({
                        action: currentInstruction.action,
                        thought: currentInstruction.thought,
                        position: {
                            x: redCharacter.position.x,
                            y: redCharacter.position.y,
                            z: redCharacter.position.z
                        },
                        grid: getGridPosition(redCharacter.position)
                    });
                    
                    redInstructionTimer = 0;
                    redInstructionIndex++;
                    
                    // Get new instruction when current one is complete
                    if (redInstructionIndex >= redAIInstructions.length) {
                        isLoadingRedInstructions = true;
                        document.getElementById('enemy-ai-thinking').textContent = "Planning next action...";
                        
                        getRedAIInstructions(
                            redCharacter.position, 
                            redCharacter.actionHistory,
                            redHitWall,
                            blueCharacter.position
                        ).then(instructions => {
                            redAIInstructions = instructions;
                            redInstructionIndex = 0;
                            redInstructionTimer = 0;
                            isLoadingRedInstructions = false;
                        }).catch(error => {
                            console.error("Error getting new red AI instructions:", error);
                            isLoadingRedInstructions = false;
                            document.getElementById('enemy-ai-thinking').textContent = "Error planning. Using fallback behavior.";
                            redAIInstructions = [
                                { action: 'idle', duration: 2, thought: 'Thinking what to do next' }
                            ];
                            redInstructionIndex = 0;
                        });
                    }
                }
            }
        }

        // Animation loop
        const clock = new THREE.Clock();
        let lastTime = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = clock.getElapsedTime();
            const delta = Math.min(currentTime - lastTime, 0.1);
            lastTime = currentTime;
            
            // Update orbit controls if enabled
            orbitControls.update();
            
            // Update character animation mixers
            if (blueCharacter.mixer) {
                blueCharacter.mixer.update(delta);
            }
            
            if (redCharacter.mixer) {
                redCharacter.mixer.update(delta);
            }
            
            // Process character movements
            processBlueCharacterMovement(delta);
            processRedCharacterMovement(delta);
            
            // Check for tag collision
            if (checkTagCollision()) {
                handleTag();
            }
            
            renderer.render(scene, camera);
        }
        
        function formatActionName(action) {
            if (!action) return "Unknown";
            return action
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase());
        }
        
        animate();
    </script>
</body>
</html>
