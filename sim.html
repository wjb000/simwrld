<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Controlled 3D Character Viewer (Local Models)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        #ai-status {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        #ai-thinking {
            font-style: italic;
            color: #aaffaa;
            margin-top: 5px;
        }
        #debug-info {
            margin-top: 10px;
            font-size: 12px;
            color: #aaaaaa;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 5px;
        }
        .progress-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.1s linear;
        }
        #environment-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 200px;
        }
        #model-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 4px;
            width: 100%;
            margin-top: 5px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #text-map-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            width: auto;
            height: auto;
            display: inline-block;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #text-map {
            font-family: 'Courier New', monospace;
            white-space: pre;
            margin: 0;
            line-height: 1.2;
            font-weight: bold;
            letter-spacing: 0.05em;
            text-shadow: 0 0 2px rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h2>AI-Controlled Character</h2>
        <div id="ai-status">Initializing AI system...</div>
        <div class="progress-bar"><div id="action-progress" class="progress-fill"></div></div>
        <div id="ai-thinking"></div>
        <div id="debug-info"></div>
    </div>

    <div id="model-selector">
        <h2>Model Selection</h2>
        <select id="model-choice">
            <option value="mistral7b.gguf">Mistral 7B</option>
            <option value="Llama-3-8B.gguf">llama3 8B</option>
        </select>
        <button id="load-model-btn">Load Model</button>
        <div id="model-status">No model loaded</div>
    </div>

    <div id="environment-info">
        Environment: Infinite Open World<br>
        Time: Day<br>
        Weather: Clear
    </div>

    <div id="text-map-container">
        <h2>AI's Map View</h2>
        <pre id="text-map"></pre>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Python server endpoint for model inference
        const PYTHON_SERVER_URL = 'http://localhost:5000';

        // Scene setup with optimized infinite environment
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.FogExp2(0x87ceeb, 0.01); // Increased fog density to mask distant unloading

// Global materials for reuse
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x7cfc00, roughness: 0.8, metalness: 0.1 });
const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7, metalness: 0.2 });
const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8, metalness: 0.1 });
const houseMaterial = new THREE.MeshStandardMaterial({ color: 0xd3b88c, roughness: 0.7, metalness: 0.1 });
const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x2d572c, roughness: 0.8, metalness: 0.1 });

// Infinite terrain system
const chunkSize = 50; // Smaller chunks for finer control and less overhead
const chunksVisibleInViewDistance = 1; // Only 1 chunk around the character (9 total)
const loadedChunks = new Map();
const activeChunks = new Set();
let lastChunkUpdatePosition = { x: 0, z: 0 };
const updateThreshold = chunkSize / 2; // Update only when moving half a chunk

// Add a minimal infinite floor (lightweight)
const floorGeometry = new THREE.PlaneGeometry(1000, 1000); // Smaller than 10000x10000
const floorMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x7cfc00, // Fixed green color to prevent glitching
    roughness: 0.9, 
    metalness: 0.1,
    side: THREE.DoubleSide // Ensure it's visible from both sides
});
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -0.01; // Slightly below ground to prevent z-fighting
floor.receiveShadow = true;
scene.add(floor);

// Add wooden platform at (10, 0.5, 10)
const platformGeometry = new THREE.BoxGeometry(10, 0.5, 10);
const platform = new THREE.Mesh(platformGeometry, platformMaterial);
platform.position.set(10, 0.25, 10);
platform.castShadow = true;
platform.receiveShadow = true;
scene.add(platform);

// Chunk utilities
function getChunkKey(chunkX, chunkZ) {
    return `${chunkX},${chunkZ}`;
}

function getChunkCoords(worldX, worldZ) {
    return {
        x: Math.floor(worldX / chunkSize),
        z: Math.floor(worldZ / chunkSize)
    };
}

// Optimized terrain chunk creation for a heavily wooded town
function createTerrainChunk(chunkX, chunkZ) {
    const chunkKey = getChunkKey(chunkX, chunkZ);
    if (loadedChunks.has(chunkKey)) {
        activeChunks.add(chunkKey);
        return loadedChunks.get(chunkKey);
    }

    const chunkGroup = new THREE.Group();
    chunkGroup.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize);

    // Simplified ground (flat for performance)
    const groundGeometry = new THREE.PlaneGeometry(chunkSize, chunkSize, 1, 1); // Simpler geometry
    const ground = new THREE.Mesh(groundGeometry, groundMaterial.clone()); // Clone material to avoid sharing
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0; // Ensure ground is at y=0
    ground.receiveShadow = true;
    chunkGroup.add(ground);

    // Add environment objects for a heavily wooded town
    addEnvironmentObjects(chunkGroup, chunkX, chunkZ);

    scene.add(chunkGroup);
    loadedChunks.set(chunkKey, chunkGroup);
    activeChunks.add(chunkKey);

    return chunkGroup;
}

// Strategically place objects for a heavily wooded town
function addEnvironmentObjects(chunkGroup, chunkX, chunkZ) {
    const chunkSeed = Math.abs(chunkX * 10000 + chunkZ);
    const pseudoRandom = (seed) => ((seed * 9301 + 49297) % 233280) / 233280;

    const objectPositions = [];
    
    // Generate positions for objects - use fixed positions for more consistent placement
    const positions = [];
    const numPositions = 40; // More positions to try
    
    // Use a grid-based approach for more even distribution
    const gridCells = 5; // 5x5 grid within each chunk
    const cellSize = chunkSize / gridCells;
    
    for (let i = 0; i < gridCells; i++) {
        for (let j = 0; j < gridCells; j++) {
            // Add some randomness within each cell
            const offsetX = (pseudoRandom(chunkSeed + i*100 + j) - 0.5) * cellSize * 0.8;
            const offsetZ = (pseudoRandom(chunkSeed + i*100 + j + 50) - 0.5) * cellSize * 0.8;
            
            // Calculate position within chunk
            const x = (i + 0.5) * cellSize - chunkSize/2 + offsetX;
            const z = (j + 0.5) * cellSize - chunkSize/2 + offsetZ;
            
            positions.push({ 
                x, 
                z, 
                seed: chunkSeed + i*100 + j 
            });
        }
    }
    
    // Function to check if a position is too close to existing objects
    function isTooClose(x, z, minDistance) {
        return objectPositions.some(pos => {
            const dx = pos.x - x;
            const dz = pos.z - z;
            return dx * dx + dz * dz < minDistance * minDistance;
        });
    }

    // Function to add an object if it doesn't conflict with existing ones
    function addObject(x, z, minDistance, createFunc, heightOffset = 0) {
        const worldX = x + chunkX * chunkSize;
        const worldZ = z + chunkZ * chunkSize;

        // Avoid platform area
        if (worldX >= 5 && worldX <= 15 && worldZ >= 5 && worldZ <= 15) return false;

        if (!isTooClose(x, z, minDistance)) {
            const object = createFunc(pseudoRandom(chunkSeed + objectPositions.length * 31));
            object.position.set(x, heightOffset, z);
            chunkGroup.add(object);
            objectPositions.push({ x, z });
            return true;
        }
        return false;
    }

    // Place trees (ensure at least 5 trees per chunk for dense forest feel)
    let treesPlaced = 0;
    const minTrees = 5;
    const maxTrees = 12; // More trees
    
    // First pass - try to place minimum number of trees
    for (let i = 0; i < positions.length && treesPlaced < minTrees; i++) {
        if (addObject(positions[i].x, positions[i].z, 4, createTree)) { // Reduced minimum distance
            treesPlaced++;
        }
    }
    
    // Second pass - add more trees up to max if possible
    for (let i = 0; i < positions.length && treesPlaced < maxTrees; i++) {
        if (addObject(positions[i].x, positions[i].z, 4, createTree)) {
            treesPlaced++;
        }
    }

    // Add houses (1-2 per chunk with 40% probability)
    if (pseudoRandom(chunkSeed) < 0.4) {
        let housesPlaced = 0;
        const maxHouses = 2;
        for (let i = 0; i < positions.length && housesPlaced < maxHouses; i++) {
            if (addObject(positions[i].x, positions[i].z, 10, createHouse)) {
                housesPlaced++;
            }
        }
    }

    // Add benches (30% probability per chunk)
    if (pseudoRandom(chunkSeed + 100) < 0.3) {
        for (let i = 0; i < positions.length; i++) {
            if (addObject(positions[i].x, positions[i].z, 5, createBench)) {
                break; // Just add one bench per chunk
            }
        }
    }
}

// Simplified object creation functions
function createTree(randomSeed) {
    const tree = new THREE.Group();
    const trunkHeight = 1.5 + randomSeed * 1.5;
    
    // Create trunk
    const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.3, trunkHeight, 8),
        woodMaterial.clone() // Clone material to avoid sharing
    );
    trunk.position.y = trunkHeight / 2;
    trunk.castShadow = true;
    trunk.receiveShadow = true;
    tree.add(trunk);

    // Create foliage (cone shape)
    const foliage = new THREE.Mesh(
        new THREE.ConeGeometry(1 + randomSeed * 0.5, 2 + randomSeed, 8),
        foliageMaterial.clone() // Clone material to avoid sharing
    );
    foliage.position.y = trunkHeight + 1;
    foliage.castShadow = true;
    foliage.receiveShadow = true;
    tree.add(foliage);

    return tree;
}

function createHouse(randomSeed) {
    const house = new THREE.Group();
    const baseWidth = 3 + randomSeed * 2;
    const baseDepth = 2 + randomSeed;
    const baseHeight = 2;
    
    // Create house base
    const base = new THREE.Mesh(
        new THREE.BoxGeometry(baseWidth, baseHeight, baseDepth),
        houseMaterial.clone() // Clone material to avoid sharing
    );
    base.position.y = baseHeight / 2;
    base.castShadow = true;
    base.receiveShadow = true;
    house.add(base);

    // Create roof
    const roofHeight = 1.5;
    const roof = new THREE.Mesh(
        new THREE.ConeGeometry(Math.max(baseWidth, baseDepth) / 1.5, roofHeight, 4),
        woodMaterial.clone() // Clone material to avoid sharing
    );
    roof.position.y = baseHeight + roofHeight / 2;
    roof.rotation.y = Math.PI / 4;
    roof.castShadow = true;
    roof.receiveShadow = true;
    house.add(roof);
    
    // Add a door
    const door = new THREE.Mesh(
        new THREE.PlaneGeometry(0.8, 1.5),
        new THREE.MeshStandardMaterial({ color: 0x4d2926, roughness: 0.9 })
    );
    door.position.set(0, 0.75, baseDepth/2 + 0.01);
    house.add(door);
    
    // Add windows
    const windowMaterial = new THREE.MeshStandardMaterial({ color: 0xadd8e6, roughness: 0.3, metalness: 0.5 });
    
    const window1 = new THREE.Mesh(
        new THREE.PlaneGeometry(0.6, 0.6),
        windowMaterial
    );
    window1.position.set(-baseWidth/4, baseHeight/2 + 0.3, baseDepth/2 + 0.01);
    house.add(window1);
    
    const window2 = new THREE.Mesh(
        new THREE.PlaneGeometry(0.6, 0.6),
        windowMaterial
    );
    window2.position.set(baseWidth/4, baseHeight/2 + 0.3, baseDepth/2 + 0.01);
    house.add(window2);

    return house;
}

function createBench() {
    const bench = new THREE.Group();
    
    // Create seat
    const seat = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.1, 0.6),
        woodMaterial.clone() // Clone material to avoid sharing
    );
    seat.position.y = 0.5;
    seat.castShadow = true;
    seat.receiveShadow = true;
    bench.add(seat);

    // Create backrest
    const backrest = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.6, 0.1),
        woodMaterial.clone() // Clone material to avoid sharing
    );
    backrest.position.set(0, 0.8, -0.25);
    backrest.castShadow = true;
    backrest.receiveShadow = true;
    bench.add(backrest);
    
    // Create legs
    const legMaterial = woodMaterial.clone();
    legMaterial.color.setHex(0x5d3a1a); // Darker wood for legs
    
    const leg1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.5, 0.1),
        legMaterial
    );
    leg1.position.set(-0.8, 0.25, 0.2);
    bench.add(leg1);
    
    const leg2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.5, 0.1),
        legMaterial
    );
    leg2.position.set(0.8, 0.25, 0.2);
    bench.add(leg2);
    
    const leg3 = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.5, 0.1),
        legMaterial
    );
    leg3.position.set(-0.8, 0.25, -0.2);
    bench.add(leg3);
    
    const leg4 = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.5, 0.1),
        legMaterial
    );
    leg4.position.set(0.8, 0.25, -0.2);
    bench.add(leg4);

    return bench;
}

// Optimized chunk update for infinite world
function updateVisibleChunks() {
    if (!character?.isLoaded) return;

    const { x, z } = getChunkCoords(character.position.x, character.position.z);
    const dx = Math.abs(character.position.x - lastChunkUpdatePosition.x);
    const dz = Math.abs(character.position.z - lastChunkUpdatePosition.z);

    // Force update on first load or when moved significantly
    const shouldUpdate = activeChunks.size === 0 || dx > updateThreshold || dz > updateThreshold;
    
    if (!shouldUpdate) return;

    lastChunkUpdatePosition = { x: character.position.x, z: character.position.z };
    
    console.log("Updating chunks at", x, z);

    // Load nearby chunks
    for (let offsetX = -chunksVisibleInViewDistance; offsetX <= chunksVisibleInViewDistance; offsetX++) {
        for (let offsetZ = -chunksVisibleInViewDistance; offsetZ <= chunksVisibleInViewDistance; offsetZ++) {
            createTerrainChunk(x + offsetX, z + offsetZ);
        }
    }

    // Unload distant chunks to keep scene lightweight
    for (const [key, chunk] of loadedChunks.entries()) {
        const [chunkX, chunkZ] = key.split(',').map(Number);
        const distance = Math.max(Math.abs(x - chunkX), Math.abs(z - chunkZ));
        if (distance > chunksVisibleInViewDistance + 1) {
            scene.remove(chunk);
            loadedChunks.delete(key);
            activeChunks.delete(key);
        }
    }
}
// Function to generate a text-based grid map with enhanced information
function generateTextMap(characterPosition) {
    const gridSize = 9; // Smaller 9x9 grid centered on character
    const cellSize = 10; // Each cell represents 10x10 units in the 3D world
    
    // Calculate grid boundaries
    const centerX = Math.floor(characterPosition.x / cellSize);
    const centerZ = Math.floor(characterPosition.z / cellSize);
    const startX = centerX - Math.floor(gridSize / 2);
    const startZ = centerZ - Math.floor(gridSize / 2);
    
    // Get character's facing direction
    const facingAngle = character.rotation;
    let directionSymbol = "^"; // Default north - using simpler symbols
    let directionName = "North";
    
    // Convert rotation angle to cardinal direction symbol
    if (facingAngle >= -Math.PI/4 && facingAngle < Math.PI/4) {
        directionSymbol = "^"; // North
        directionName = "North";
    } else if (facingAngle >= Math.PI/4 && facingAngle < 3*Math.PI/4) {
        directionSymbol = ">"; // East
        directionName = "East";
    } else if (facingAngle >= 3*Math.PI/4 || facingAngle < -3*Math.PI/4) {
        directionSymbol = "v"; // South
        directionName = "South";
    } else if (facingAngle >= -3*Math.PI/4 && facingAngle < -Math.PI/4) {
        directionSymbol = "<"; // West
        directionName = "West";
    }
    
    let textMap = "";
    
    // Add simple header with position and facing direction
    textMap += `POSITION: X:${Math.round(characterPosition.x)}, Z:${Math.round(characterPosition.z)} | FACING: ${directionName}\n\n`;
    
    // Generate the grid with simpler ASCII characters
    textMap += "+";
    for (let x = 0; x < gridSize; x++) {
        textMap += "---+";
    }
    textMap += "\n";
    
    // Generate the grid
    for (let z = 0; z < gridSize; z++) {
        const worldZ = (startZ + z) * cellSize;
        textMap += "|";
        
        for (let x = 0; x < gridSize; x++) {
            const worldX = (startX + x) * cellSize;
            
            // Determine what's at this grid cell
            let cellChar = " ";
            
            // Check if this is the character's position
            if (Math.floor(characterPosition.x / cellSize) === startX + x && 
                Math.floor(characterPosition.z / cellSize) === startZ + z) {
                cellChar = directionSymbol; // Use direction symbol
            }
            // Check if this is the platform position (at x=10, z=10)
            else if (worldX >= 5 && worldX <= 15 && worldZ >= 5 && worldZ <= 15) {
                cellChar = "P"; // Platform
            }
            // Check for environment features based on world coordinates
            else {
                const seed = Math.abs(worldX * 10000 + worldZ);
                const pseudoRandom = (seed * 9301 + 49297) % 233280 / 233280;
                
                if (pseudoRandom < 0.05) {
                    cellChar = "H"; // House
                } else if (pseudoRandom < 0.25) {
                    cellChar = "T"; // Tree (higher probability for wooded feel)
                } else if (pseudoRandom < 0.30) {
                    cellChar = "B"; // Bench
                }
            }
            
            textMap += " " + cellChar + " |";
        }
        textMap += "\n+";
        
        for (let x = 0; x < gridSize; x++) {
            textMap += "---+";
        }
        textMap += "\n";
    }
    
    // Add simple compass
    textMap += "\n  N  \n";
    textMap += "W + E\n";
    textMap += "  S  \n";
    
    // Add simple legend
    textMap += "\nLegend:\n";
    textMap += `${directionSymbol} = You (facing ${directionName})\n`;
    textMap += "P = Platform (at coordinates 10,10)\n";
    textMap += "H = House\n";
    textMap += "T = Tree\n";
    textMap += "B = Bench\n";
    textMap += "  = Open Space\n";
    
    // Add goal information
    textMap += "\nGOAL: Explore the infinite wooded town\n";
    
    // Add distance to platform
    const distToPlatform = Math.round(Math.sqrt(
        Math.pow(characterPosition.x - 10, 2) + 
        Math.pow(characterPosition.z - 10, 2)
    ));
    
    textMap += `Distance to platform: ${distToPlatform} units\n`;
    
    // Add simple direction to platform
    const angleToPlatform = Math.atan2(10 - characterPosition.z, 10 - characterPosition.x);
    let platformDirection = "";
    
    if (angleToPlatform >= -Math.PI/4 && angleToPlatform < Math.PI/4) {
        platformDirection = "East";
    } else if (angleToPlatform >= Math.PI/4 && angleToPlatform < 3*Math.PI/4) {
        platformDirection = "North";
    } else if (angleToPlatform >= 3*Math.PI/4 || angleToPlatform < -3*Math.PI/4) {
        platformDirection = "West";
    } else if (angleToPlatform >= -3*Math.PI/4 && angleToPlatform < -Math.PI/4) {
        platformDirection = "South";
    }
    
    textMap += `Platform is to the ${platformDirection} of you\n`;
    
    return textMap;
}

// AI Movement Control with local model inference
async function getAIMovementInstructions(currentPosition, previousActions = [], hitObstacle = false) {
    try {
        const statusElement = document.getElementById('ai-thinking');
        statusElement.textContent = "AI is thinking about what to do next...";
        
        const modelChoice = document.getElementById('model-choice').value;
        
        // Generate the text-based map
        const textMap = generateTextMap(currentPosition);
        
        // Send request to local Python server
        const response = await fetch(PYTHON_SERVER_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model_id: modelChoice,
                position: {
                    x: currentPosition.x,
                    y: currentPosition.y,
                    z: currentPosition.z
                },
                hit_wall: hitObstacle,
                previous_actions: previousActions.slice(-3),
                prompt: `You are an AI controlling a 3D character in an infinite virtual environment resembling a heavily wooded town with trees, houses, benches, and a wooden platform at (10, 0.5, 10). You decide what the character does next based on its current state and surroundings.

The character is at position (${currentPosition.x.toFixed(1)}, ${currentPosition.y.toFixed(1)}, ${currentPosition.z.toFixed(1)}) in an infinite wooded town.
${hitObstacle ? 'The character just hit an obstacle.' : ''}

Here is a text-based map of the surrounding area:
${textMap}
                
Generate ONE natural, lifelike movement for the character to perform next. Return ONLY valid JSON with a single object containing:
- "action": one of [moveForward, moveBackward, moveLeft, moveRight, jump, sprint, idle, explore, lookAround]
- "duration": time in seconds (between 0.5 and 4)
- "thought": a brief description of the character's intention (like "Heading to the platform" or "Exploring the nearby trees")

Create an action that would make sense for a character exploring this wooded town, possibly interacting with the features around them. Make the movement feel natural and purposeful.

Previous actions: ${JSON.stringify(previousActions.slice(-3))}`
            })
        });
        
        // Get the response data
        const data = await response.json();
        
        console.log('AI Response:', data);
        statusElement.textContent = "";
        
        return [data];
    } catch (error) {
        console.error('Error fetching AI instructions:', error);
        document.getElementById('ai-thinking').textContent = "AI connection error. Using fallback behavior.";
        
        return [
            { action: 'idle', duration: 2, thought: 'Taking in the surroundings' }
        ];
    }
}
        

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -70;
        directionalLight.shadow.camera.right = 70;
        directionalLight.shadow.camera.top = 70;
        directionalLight.shadow.camera.bottom = -70;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x7cfc00, 0.3);
        scene.add(hemisphereLight);

        // Camera and renderer setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.minDistance = 5;
        orbitControls.maxDistance = 30;
        orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;
        orbitControls.enabled = false;

        // Character controller settings
        const characterControls = {
            moveSpeed: 0.1,
            sprintMultiplier: 2,
            jumpForce: 0.3,
            gravity: 0.01,
            airControl: 0.3,
            friction: 0.9,
            linearDamping: 0.95,
            groundDetectionRayLength: 1.0, // Increased to better detect ground
            groundOffset: 0.1, // Reduced to keep character closer to ground
            cameraHeight: 1.8,
            cameraDistance: 3,
            cameraSmoothing: 0.1,
            lookAtHeight: 1.0,
            rotationSpeed: 0.1,
            collisionRadius: 0.5  // For collision detection
        };

        // Character state
        const character = {
            model: null,
            mixer: null,
            animations: {},
            currentAnimation: null,
            position: new THREE.Vector3(0, 0.1, 0), // Start closer to ground
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: 0,
            targetRotation: 0,
            isGrounded: false,
            isMoving: false,
            isSprinting: false,
            isJumping: false,
            isLookingAround: false,
            previousState: null,
            isLoaded: false,
            actionHistory: []
        };

        // Camera state
        const cameraState = {
            mode: 'follow',
            rotation: { x: 0, y: 0 },
            targetRotation: { x: 0, y: 0 },
            fixedDistance: characterControls.cameraDistance,
            currentDistance: characterControls.cameraDistance,
            height: characterControls.cameraHeight,
            smoothFactor: 0.1,
            isLocked: false
        };

        // AI control state
        let aiInstructions = [];
        let currentInstructionIndex = 0;
        let instructionTimer = 0;
        let isLoadingInstructions = false;
        let sequenceCompleted = false;
        let lastThoughtChangeTime = 0;
        let currentThought = "";
        let modelLoaded = false;
        let hitObstacle = false;  // Track obstacle collisions

        // Model loading
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
        
        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        
        document.getElementById('debug-info').innerHTML = 'Loading model...';
        
        loader.load(
            'character.glb',
            async function (gltf) {
                character.model = gltf.scene;
                
                const box = new THREE.Box3().setFromObject(character.model);
                const center = box.getCenter(new THREE.Vector3());
                character.model.position.x = -center.x;
                character.model.position.z = -center.z;
                
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                if (maxDim > 2) {
                    const scale = 2 / maxDim;
                    character.model.scale.set(scale, scale, scale);
                }
                
                // Ensure character is positioned correctly on the ground
                character.position.y = 0.5; // Start at y=0.5 to be on ground
                character.model.position.copy(character.position);
                
                character.model.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                scene.add(character.model);
                
                if (gltf.animations && gltf.animations.length) {
                    character.mixer = new THREE.AnimationMixer(character.model);
                    gltf.animations.forEach((clip) => {
                        const name = clip.name.toUpperCase();
                        character.animations[name] = character.mixer.clipAction(clip);
                        character.animations[name].setLoop(THREE.LoopRepeat);
                    });
                    
                    if (character.animations['IDLE']) {
                        character.animations['IDLE'].play();
                        character.currentAnimation = 'IDLE';
                    } else if (gltf.animations.length > 0) {
                        const firstAnim = gltf.animations[0].name.toUpperCase();
                        character.animations[firstAnim].play();
                        character.currentAnimation = firstAnim;
                    }
                }
                
                document.getElementById('debug-info').innerHTML = 'Model loaded successfully<br>Animations: ' + 
                    Object.keys(character.animations).join(', ');
                
                // Mark character as loaded only after everything is set up
                character.isLoaded = true;
                
                // Force ground check immediately
                checkGrounded();
                
                updateCameraPosition(true);
                
                // Initialize the first terrain chunks around the character
                updateVisibleChunks();
            },
            function (progress) {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                document.getElementById('debug-info').innerHTML = `Loading model: ${percent}%`;
            },
            function (error) {
                console.error('Error loading model:', error);
                document.getElementById('debug-info').innerHTML = 'Model loading error: ' + error.message;
            }
        );

        // Animation handling
        function setAnimation(animName) {
            if (!character.mixer || !character.animations[animName]) {
                return;
            }
            
            if (character.currentAnimation !== animName || 
                (animName === 'RUN' && character.previousState !== character.isSprinting)) {
                const prevAnim = character.animations[character.currentAnimation];
                const nextAnim = character.animations[animName];
                
                nextAnim.reset().fadeIn(0.2).play();
                nextAnim.timeScale = (animName === 'RUN' && character.isSprinting) ? 1.25 : 1;
                
                if (prevAnim && prevAnim !== nextAnim) {
                    prevAnim.fadeOut(0.2);
                }
                
                character.currentAnimation = animName;
                character.previousState = character.isSprinting;
            }
        }

        // Ground detection with multiple surfaces
        function checkGrounded() {
            if (!character.isLoaded) return false;
            
            const raycaster = new THREE.Raycaster(
                character.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
                new THREE.Vector3(0, -1, 0),
                0,
                characterControls.groundDetectionRayLength
            );
            
            // Get all objects in the scene that could be ground
            const groundObjects = [];
            
            // Add the platform
            groundObjects.push(platform);
            
            // Add the main floor
            groundObjects.push(floor);
            
            // Add ground from loaded chunks
            for (const chunk of loadedChunks.values()) {
                chunk.children.forEach(child => {
                    if (child.isObject3D && child.type === 'Mesh' && 
                        child.rotation.x === -Math.PI / 2) {
                        groundObjects.push(child);
                    }
                });
            }
            
            const intersects = raycaster.intersectObjects(groundObjects, true);
            
            character.isGrounded = intersects.length > 0;
            if (character.isGrounded) {
                character.position.y = intersects[0].point.y + characterControls.groundOffset;
                
                // If character was falling, reset vertical velocity
                if (character.velocity.y < 0) {
                    character.velocity.y = 0;
                }
            }
            
            return character.isGrounded;
        }

        // Obstacle collision detection
        function checkObstacleCollision(newPosition) {
            // Create a sphere representing the character's collision volume
            const characterRadius = characterControls.collisionRadius;
            const characterSphere = new THREE.Sphere(
                new THREE.Vector3(newPosition.x, newPosition.y + characterRadius, newPosition.z),
                characterRadius
            );
            
            // Check for collisions with environment objects
            for (const chunk of loadedChunks.values()) {
                for (const object of chunk.children) {
                    // Skip ground planes and very small objects
                    if (object.type === 'Mesh' && object.rotation.x === -Math.PI / 2) continue;
                    if (object.type === 'Group') {
                        // For groups (like houses, trees), check their children
                        let hasCollision = false;
                        object.traverse(child => {
                            if (child.isMesh && child !== object) {
                                const objectBox = new THREE.Box3().setFromObject(child);
                                if (objectBox.intersectsSphere(characterSphere)) {
                                    hasCollision = true;
                                }
                            }
                        });
                        if (hasCollision) return true;
                    } else if (object.isMesh) {
                        // For simple meshes, check directly
                        const objectBox = new THREE.Box3().setFromObject(object);
                        if (objectBox.intersectsSphere(characterSphere)) {
                            return true;
                        }
                    }
                }
            }
            
            // Check collision with the platform
            const platformBox = new THREE.Box3().setFromObject(platform);
            if (platformBox.intersectsSphere(characterSphere)) {
                // If we're above the platform, it's not a collision (we can stand on it)
                if (newPosition.y > platform.position.y + 0.25) {
                    return false;
                }
                return true;
            }
            
            return false;
        }

        // Camera positioning
        function updateCameraPosition(initial = false) {
            if (!character.model || !character.isLoaded) {
                return;
            }
            
            if (cameraState.mode === 'orbit') {
                orbitControls.target.copy(character.position.clone().add(new THREE.Vector3(0, characterControls.lookAtHeight, 0)));
                orbitControls.update();
                return;
            }
            
            const idealOffset = new THREE.Vector3(
                0,
                characterControls.cameraHeight,
                characterControls.cameraDistance
            );
            
            idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.rotation.y);
            idealOffset.add(character.position);
            
            if (initial) {
                camera.position.copy(idealOffset);
            } else {
                camera.position.lerp(idealOffset, characterControls.cameraSmoothing);
            }
            
            const lookAtPos = character.position.clone();
            lookAtPos.y += characterControls.lookAtHeight;
            
            camera.lookAt(lookAtPos);
            camera.rotateX(cameraState.rotation.x);
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Camera mode toggle
        window.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                cameraState.mode = cameraState.mode === 'follow' ? 'orbit' : 'follow';
                orbitControls.enabled = cameraState.mode === 'orbit';
                
                if (cameraState.mode === 'orbit') {
                    orbitControls.target.copy(character.position.clone().add(new THREE.Vector3(0, 1, 0)));
                }
            }
        });

        // Model loading button
        document.getElementById('load-model-btn').addEventListener('click', async () => {
            const modelChoice = document.getElementById('model-choice').value;
            const modelStatus = document.getElementById('model-status');
            const loadButton = document.getElementById('load-model-btn');
            
            loadButton.disabled = true;
            modelStatus.textContent = `Loading ${modelChoice}...`;
            
            try {
                // Send request to check if model is loaded
                const response = await fetch(`${PYTHON_SERVER_URL}/check-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: modelChoice
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    modelStatus.textContent = `Model ${modelChoice} loaded successfully`;
                    modelLoaded = true;
                    
                    // Start AI instructions once model is loaded
                    if (character.isLoaded && !isLoadingInstructions) {
                        isLoadingInstructions = true;
                        aiInstructions = await getAIMovementInstructions(character.position, character.actionHistory, hitObstacle);
                        isLoadingInstructions = false;
                    }
                } else {
                    modelStatus.textContent = `Error: ${data.error}`;
                }
            } catch (error) {
                modelStatus.textContent = `Connection error: ${error.message}`;
                console.error('Error checking model:', error);
            }
            
            loadButton.disabled = false;
        });

        // Animation loop
        const clock = new THREE.Clock();
        let lastTime = 0;
        
        async function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = clock.getElapsedTime();
            const delta = Math.min(currentTime - lastTime, 0.1);
            lastTime = currentTime;
            
            if (cameraState.mode === 'orbit') {
                orbitControls.update();
            }
            
            if (character.mixer) {
                character.mixer.update(delta);
            }
            
            // Update visible chunks as character moves
            if (character.isLoaded) {
                updateVisibleChunks();
            }
            
            if (!character.isLoaded || !modelLoaded || isLoadingInstructions) {
                renderer.render(scene, camera);
                return;
            }
            
            // Always check if character is grounded
            checkGrounded();
            
            if (!sequenceCompleted && aiInstructions.length > 0) {
                const currentInstruction = aiInstructions[currentInstructionIndex];
                
                if (!currentInstruction || !currentInstruction.action) {
                    instructionTimer = 0;
                    currentInstructionIndex++;
                    return;
                }
                
                instructionTimer += delta;
                
                const progressPercent = (instructionTimer / currentInstruction.duration) * 100;
                document.getElementById('action-progress').style.width = `${Math.min(progressPercent, 100)}%`;
                
                document.getElementById('ai-status').innerHTML = 
                    `<strong>Action:</strong> ${formatActionName(currentInstruction.action)}<br>` +
                    `<strong>Thought:</strong> ${currentInstruction.thought || "..."}<br>` +
                    `<strong>Progress:</strong> ${Math.min(Math.floor(progressPercent), 100)}%`;
                
                character.isMoving = false;
                character.isSprinting = false;
                character.isJumping = false;
                character.isLookingAround = false;
                character.velocity.x = 0;
                character.velocity.z = 0;
                
                // Calculate movement directions
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.rotation.y);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);
                right.normalize();
                
                let moveDirection = new THREE.Vector3();
                
                switch (currentInstruction.action.toLowerCase()) {
                    case 'moveforward':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        break;
                    case 'movebackward':
                        moveDirection.sub(forward);
                        character.isMoving = true;
                        break;
                    case 'moveleft':
                        moveDirection.add(right);
                        character.isMoving = true;
                        break;
                    case 'moveright':
                        moveDirection.sub(right);
                        character.isMoving = true;
                        break;
                    case 'sprint':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        character.isSprinting = true;
                        break;
                    case 'jump':
                        if (character.isGrounded) {
                            character.isJumping = true;
                            character.velocity.y = characterControls.jumpForce;
                        }
                        break;
                    case 'idle':
                        // No movement in idle state
                        break;
                    case 'lookaround':
                        character.isLookingAround = true;
                        // Rotate camera slightly for looking around effect
                        cameraState.rotation.y += Math.sin(currentTime * 0.5) * 0.01;
                        break;
                    case 'explore':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        // Occasionally change direction during exploration
                        if (Math.random() < 0.05) {
                            cameraState.rotation.y += (Math.random() - 0.5) * 0.1;
                        }
                        break;
                    default:
                        console.warn('Unknown action:', currentInstruction.action);
                }
                
                // Update character rotation to match movement direction
                if (character.isMoving && moveDirection.length() > 0) {
                    moveDirection.normalize();
                    character.rotation = Math.atan2(moveDirection.x, moveDirection.z);
                    character.model.rotation.y = character.rotation;
                }
                
                if (character.isMoving) {
                    const speed = characterControls.moveSpeed * 
                        (character.isSprinting ? characterControls.sprintMultiplier : 1) * 
                        (character.isGrounded ? 1 : characterControls.airControl);
                    
                    character.velocity.x = moveDirection.x * speed;
                    character.velocity.z = moveDirection.z * speed;
                } else {
                    character.velocity.x *= characterControls.friction;
                    character.velocity.z *= characterControls.friction;
                }
                
                // Apply gravity and ground constraints
                if (!character.isGrounded) {
                    character.velocity.y -= characterControls.gravity;
                } else if (!character.isJumping) {
                    character.velocity.y = 0;
                }
                
                // Set appropriate animation based on character state
                if (!character.isGrounded && character.velocity.y < 0) {
                    setAnimation('FALL');
                } else if (character.isJumping) {
                    setAnimation('JUMP');
                } else if (character.isMoving) {
                    if (character.isSprinting && character.animations['RUN']) {
                        setAnimation('RUN');
                    } else if (character.animations['WALK']) {
                        setAnimation('WALK');
                    } else if (character.animations['RUN']) {
                        setAnimation('RUN');
                    }
                } else if (character.isLookingAround && character.animations['IDLE_LOOK']) {
                    setAnimation('IDLE_LOOK');
                } else {
                    setAnimation('IDLE');
                }
                
                // Calculate new position with velocity
                const newPosition = character.position.clone().add(character.velocity);
                
                // Check for obstacle collisions before applying movement
                hitObstacle = checkObstacleCollision(newPosition);
                
                if (!hitObstacle) {
                    // No collision, apply movement
                    character.position.copy(newPosition);
                } else {
                    // Collision detected, try sliding along obstacles
                    // Try moving only in X direction
                    const newPositionX = character.position.clone();
                    newPositionX.x += character.velocity.x;
                    
                    if (!checkObstacleCollision(newPositionX)) {
                        character.position.x = newPositionX.x;
                    }
                    
                    // Try moving only in Z direction
                    const newPositionZ = character.position.clone();
                    newPositionZ.z += character.velocity.z;
                    
                    if (!checkObstacleCollision(newPositionZ)) {
                        character.position.z = newPositionZ.z;
                    }
                    
                    // Reset velocity in directions that had collisions
                    if (character.position.x !== newPosition.x) {
                        character.velocity.x = 0;
                    }
                    if (character.position.z !== newPosition.z) {
                        character.velocity.z = 0;
                    }
                }
                
                // Update model position
                character.model.position.copy(character.position);
                
                // Check if current instruction is complete
                if (instructionTimer >= currentInstruction.duration) {
                    character.actionHistory.push({
                        action: currentInstruction.action,
                        thought: currentInstruction.thought,
                        position: {
                            x: character.position.x,
                            y: character.position.y,
                            z: character.position.z
                        }
                    });
                    
                    instructionTimer = 0;
                    currentInstructionIndex++;
                    
                    // Reset character state when instruction completes
                    character.isMoving = false;
                    character.isSprinting = false;
                    character.isJumping = false;
                    character.isLookingAround = false;
                    character.velocity.x = 0;
                    character.velocity.z = 0;
                    
                    // Force idle animation between instructions
                    setAnimation('IDLE');
                    
                    // Get new instruction when current one is complete
                    if (currentInstructionIndex >= aiInstructions.length) {
                        isLoadingInstructions = true;
                        document.getElementById('ai-thinking').textContent = "Planning next action...";
                        
                        try {
                            // Get a single new instruction for more dynamic behavior
                            aiInstructions = await getAIMovementInstructions(
                                character.position, 
                                character.actionHistory,
                                hitObstacle
                            );
                            currentInstructionIndex = 0;
                            instructionTimer = 0;
                        } catch (error) {
                            console.error("Error getting new AI instructions:", error);
                            document.getElementById('ai-thinking').textContent = "Error planning. Using fallback behavior.";
                            aiInstructions = [
                                { action: 'idle', duration: 2, thought: 'Thinking what to do next' }
                            ];
                            currentInstructionIndex = 0;
                        }
                        
                        isLoadingInstructions = false;
                    }
                }
            }
            
            // Update camera position
            updateCameraPosition();
            
            // Update the text map display
            if (character.isLoaded && modelLoaded) {
                const textMap = generateTextMap(character.position);
                document.getElementById('text-map').textContent = textMap;
            }
            
            renderer.render(scene, camera);
        }
        
        function formatActionName(action) {
            if (!action) return "Unknown";
            return action
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase());
        }
        
        animate();
    </script>
</body>
</html>
