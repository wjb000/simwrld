<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Controlled 3D Character - Alternating Models</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        #ai-status {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        #ai-thinking {
            font-style: italic;
            color: #aaffaa;
            margin-top: 5px;
        }
        #debug-info {
            margin-top: 10px;
            font-size: 12px;
            color: #aaaaaa;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 5px;
        }
        .progress-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.1s linear;
        }
        #environment-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 200px;
        }
        #model-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 4px;
            width: 100%;
            margin-top: 5px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #grid-info {
            position: absolute;
            top: 10px;
            left: 320px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #grid-content {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        #active-model {
            font-weight: bold;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h2>AI-Controlled Character</h2>
        <div id="ai-status">Initializing AI system...</div>
        <div class="progress-bar"><div id="action-progress" class="progress-fill"></div></div>
        <div id="ai-thinking"></div>
        <div id="debug-info"></div>
    </div>

    <div id="grid-info">
        <h2>Grid Position</h2>
        <div id="grid-content">Waiting for movement...</div>
        <div id="active-model">Current Model: None</div>
    </div>

    <div id="model-selector">
        <h2>Model Selection</h2>
        <div>
            <label>Model 1:</label>
            <select id="model-1-choice">
                <option value="mlx-community/Llama-3.2-1B-Instruct-4bit">Llama-3.2-1B</option>
                <option value="nidum/Nidum-Llama-3.2-3B-Uncensored-MLX-4bit">Nidum-Llama-3.2-3B</option>
            </select>
        </div>
        <div style="margin-top: 10px;">
            <label>Model 2:</label>
            <select id="model-2-choice">
                <option value="nidum/Nidum-Llama-3.2-3B-Uncensored-MLX-4bit">Nidum-Llama-3.2-3B</option>
                <option value="mlx-community/Llama-3.2-1B-Instruct-4bit">Llama-3.2-1B</option>
            </select>
        </div>
        <button id="load-models-btn">Load Models</button>
        <div id="model-status">No models loaded</div>
    </div>

    <div id="environment-info">
        Environment: Grassy Field with Platform<br>
        Time: Day<br>
        Weather: Clear
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Python server endpoint for model inference
        const PYTHON_SERVER_URL = 'http://localhost:5000';

        // Grid size for position tracking (10x10 grid)
        const GRID_SIZE = 10;

        // Get current grid position from world coordinates
        function getGridPosition(position) {
            return {
                x: Math.floor(position.x / GRID_SIZE),
                z: Math.floor(position.z / GRID_SIZE)
            };
        }

        // AI Movement Control with alternating models
        async function getAIMovementInstructions(currentPosition, previousActions = [], hitWall = false, useModel1 = true) {
            try {
                const statusElement = document.getElementById('ai-thinking');
                statusElement.textContent = "AI is thinking about what to do next...";
                
                // Determine which model to use
                const modelChoice = useModel1 ? 
                    document.getElementById('model-1-choice').value : 
                    document.getElementById('model-2-choice').value;
                
                // Update active model display
                document.getElementById('active-model').textContent = 
                    `Current Model: ${useModel1 ? 'Model 1' : 'Model 2'} (${modelChoice.split('/').pop()})`;
                
                // Calculate current grid position
                const currentGrid = getGridPosition(currentPosition);
                
                // Update grid info display
                document.getElementById('grid-content').innerHTML = 
                    `Current Grid: (${currentGrid.x}, ${currentGrid.z})<br>` +
                    `World Position: (${currentPosition.x.toFixed(1)}, ${currentPosition.y.toFixed(1)}, ${currentPosition.z.toFixed(1)})`;
                
                // Send request to local Python server
                const response = await fetch(PYTHON_SERVER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: modelChoice,
                        position: {
                            x: currentPosition.x,
                            y: currentPosition.y,
                            z: currentPosition.z
                        },
                        current_grid: currentGrid,
                        hit_wall: hitWall,
                        previous_actions: previousActions.slice(-5)
                    })
                });
                
                const data = await response.json();
                let instructions;
                
                try {
                    // Parse the response
                    instructions = data.response;
                    
                    // If it's a string, try to parse it as JSON
                    if (typeof instructions === 'string') {
                        // Look for JSON pattern in the response
                        const jsonMatch = instructions.match(/(\{[\s\S]*\})/);
                        
                        if (jsonMatch) {
                            instructions = JSON.parse(jsonMatch[0]);
                        } else {
                            // If no JSON pattern found, try parsing the whole content
                            instructions = JSON.parse(instructions);
                        }
                    }
                    
                    // If it's an array, take just the first item
                    if (Array.isArray(instructions)) {
                        instructions = instructions[0];
                    }
                    
                    // Wrap in array for compatibility with existing code
                    instructions = [instructions];
                } catch (parseError) {
                    console.error('Parse error:', parseError);
                    console.log('Raw response:', data.response);
                    
                    // Fallback to a simple instruction if parsing fails
                    instructions = [
                        { action: 'idle', duration: 2, thought: 'Recovering from confusion' }
                    ];
                }
                
                console.log('AI Instructions:', instructions);
                statusElement.textContent = "";
                return instructions;
            } catch (error) {
                console.error('Error fetching AI instructions:', error);
                document.getElementById('ai-thinking').textContent = "AI connection error. Using fallback behavior.";
                
                return [
                    { action: 'idle', duration: 2, thought: 'Taking in the surroundings' }
                ];
            }
        }

        // Scene setup with enhanced environment
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.01);

        // Create grassy terrain
        const groundSize = 100;
        const groundSegments = 100;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, groundSegments, groundSegments);
        
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            vertices[i + 1] = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 0.5;
        }
        groundGeometry.computeVertexNormals();
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7cfc00,
            roughness: 0.8,
            metalness: 0.1,
            flatShading: false
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add wooden platform (new floor)
        const platformGeometry = new THREE.BoxGeometry(10, 0.5, 10);
        const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513, // Wood-like brown
            roughness: 0.7,
            metalness: 0.2
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.set(10, 0.25, 10); // Slightly above ground at x=10, z=10
        platform.castShadow = true;
        platform.receiveShadow = true;
        scene.add(platform);

        // Add main floor
        const floorGeometry = new THREE.BoxGeometry(100, 0.5, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555, // Dark gray
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.set(0, -0.25, 0); // Slightly below the terrain
        floor.receiveShadow = true;
        scene.add(floor);

        // Add border walls
        const wallHeight = 5;
        const wallThickness = 1;
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888, // Light gray
            roughness: 0.8,
            metalness: 0.2
        });

        // Define boundary limits for collision detection
        const boundaries = {
            minX: -49,
            maxX: 49,
            minZ: -49,
            maxZ: 49
        };

        // North wall
        const northWallGeometry = new THREE.BoxGeometry(100 + wallThickness*2, wallHeight, wallThickness);
        const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
        northWall.position.set(0, wallHeight/2, -50 - wallThickness/2);
        northWall.castShadow = true;
        northWall.receiveShadow = true;
        scene.add(northWall);

        // South wall
        const southWallGeometry = new THREE.BoxGeometry(100 + wallThickness*2, wallHeight, wallThickness);
        const southWall = new THREE.Mesh(southWallGeometry, wallMaterial);
        southWall.position.set(0, wallHeight/2, 50 + wallThickness/2);
        southWall.castShadow = true;
        southWall.receiveShadow = true;
        scene.add(southWall);

        // East wall
        const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
        const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
        eastWall.position.set(50 + wallThickness/2, wallHeight/2, 0);
        eastWall.castShadow = true;
        eastWall.receiveShadow = true;
        scene.add(eastWall);

        // West wall
        const westWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
        const westWall = new THREE.Mesh(westWallGeometry, wallMaterial);
        westWall.position.set(-50 - wallThickness/2, wallHeight/2, 0);
        westWall.castShadow = true;
        westWall.receiveShadow = true;
        scene.add(westWall);

        // Add grid markers to visualize the grid
        function addGridMarkers() {
            const gridLineGeometry = new THREE.BoxGeometry(0.1, 0.1, 100);
            const gridLineMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
            
            // Add grid lines along X axis
            for (let i = -5; i <= 5; i++) {
                const xLine = new THREE.Mesh(gridLineGeometry, gridLineMaterial);
                xLine.position.set(i * GRID_SIZE, 0.05, 0);
                scene.add(xLine);
            }
            
            // Add grid lines along Z axis
            const gridLineGeometryX = new THREE.BoxGeometry(100, 0.1, 0.1);
            for (let i = -5; i <= 5; i++) {
                const zLine = new THREE.Mesh(gridLineGeometryX, gridLineMaterial);
                zLine.position.set(0, 0.05, i * GRID_SIZE);
                scene.add(zLine);
            }
            
            // Add grid cell markers
            const markerGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
            
            for (let x = -5; x <= 5; x++) {
                for (let z = -5; z <= 5; z++) {
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.set(x * GRID_SIZE, 0.1, z * GRID_SIZE);
                    scene.add(marker);
                }
            }
        }
        
        addGridMarkers();

        // Add environment objects (trees and rocks)
        function addEnvironmentObjects() {
            const treeGeometry = new THREE.ConeGeometry(1, 4, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d572c });
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            
            for (let i = 0; i < 20; i++) {
                const tree = new THREE.Group();
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.5;
                trunk.castShadow = true;
                tree.add(trunk);
                
                const leaves = new THREE.Mesh(treeGeometry, treeMaterial);
                leaves.position.y = 3;
                leaves.castShadow = true;
                tree.add(leaves);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 30;
                tree.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                scene.add(tree);
            }
            
            const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.9,
                metalness: 0.1
            });
            
            for (let i = 0; i < 15; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                const scale = 0.5 + Math.random() * 1.5;
                rock.scale.set(scale, scale * 0.7, scale);
                rock.rotation.y = Math.random() * Math.PI * 2;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 35;
                rock.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
            }
        }
        
        addEnvironmentObjects();

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -70;
        directionalLight.shadow.camera.right = 70;
        directionalLight.shadow.camera.top = 70;
        directionalLight.shadow.camera.bottom = -70;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x7cfc00, 0.3);
        scene.add(hemisphereLight);

        // Camera and renderer setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.minDistance = 5;
        orbitControls.maxDistance = 30;
        orbitControls.maxPolarAngle = Math.PI / 2 - 0.1;
        orbitControls.enabled = false;

        // Character controller settings
        const characterControls = {
            moveSpeed: 0.1,
            sprintMultiplier: 2,
            jumpForce: 0.3,
            gravity: 0.01,
            airControl: 0.3,
            friction: 0.9,
            linearDamping: 0.95,
            groundDetectionRayLength: 1.5,
            groundOffset: 0.1,
            cameraHeight: 1.8,
            cameraDistance: 3,
            cameraSmoothing: 0.1,
            lookAtHeight: 1.0,
            rotationSpeed: 0.1,
            collisionRadius: 0.5  // Added for collision detection
        };

        // Character state
        const character = {
            model: null,
            mixer: null,
            animations: {},
            currentAnimation: null,
            position: new THREE.Vector3(0, 1, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: 0,
            targetRotation: 0,
            isGrounded: false,
            isMoving: false,
            isSprinting: false,
            isJumping: false,
            isLookingAround: false,
            previousState: null,
            isLoaded: false,
            actionHistory: []
        };

        // Camera state
        const cameraState = {
            mode: 'follow',
            rotation: { x: 0, y: 0 },
            targetRotation: { x: 0, y: 0 },
            fixedDistance: characterControls.cameraDistance,
            currentDistance: characterControls.cameraDistance,
            height: characterControls.cameraHeight,
            smoothFactor: 0.1,
            isLocked: false
        };

        // AI control state
        let aiInstructions = [];
        let currentInstructionIndex = 0;
        let instructionTimer = 0;
        let isLoadingInstructions = false;
        let sequenceCompleted = false;
        let lastThoughtChangeTime = 0;
        let currentThought = "";
        let model1Loaded = false;
        let model2Loaded = false;
        let hitWall = false;  // Track wall collisions
        let useModel1 = true; // Toggle between models

        // Model loading
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
        
        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        
        document.getElementById('debug-info').innerHTML = 'Loading model...';
        
        loader.load(
            'character.glb',
            async function (gltf) {
                character.model = gltf.scene;
                character.isLoaded = true;
                
                const box = new THREE.Box3().setFromObject(character.model);
                const center = box.getCenter(new THREE.Vector3());
                character.model.position.x = -center.x;
                character.model.position.z = -center.z;
                
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                if (maxDim > 2) {
                    const scale = 2 / maxDim;
                    character.model.scale.set(scale, scale, scale);
                }
                
                character.model.position.copy(character.position);
                
                character.model.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                scene.add(character.model);
                
                if (gltf.animations && gltf.animations.length) {
                    character.mixer = new THREE.AnimationMixer(character.model);
                    gltf.animations.forEach((clip) => {
                        const name = clip.name.toUpperCase();
                        character.animations[name] = character.mixer.clipAction(clip);
                        character.animations[name].setLoop(THREE.LoopRepeat);
                    });
                    
                    if (character.animations['IDLE']) {
                        character.animations['IDLE'].play();
                        character.currentAnimation = 'IDLE';
                    } else if (gltf.animations.length > 0) {
                        const firstAnim = gltf.animations[0].name.toUpperCase();
                        character.animations[firstAnim].play();
                        character.currentAnimation = firstAnim;
                    }
                }
                
                document.getElementById('debug-info').innerHTML = 'Model loaded successfully<br>Animations: ' + 
                    Object.keys(character.animations).join(', ');
                
                updateCameraPosition(true);
            },
            function (progress) {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                document.getElementById('debug-info').innerHTML = `Loading model: ${percent}%`;
            },
            function (error) {
                console.error('Error loading model:', error);
                document.getElementById('debug-info').innerHTML = 'Model loading error: ' + error.message;
            }
        );

        // Animation handling
        function setAnimation(animName) {
            if (!character.mixer || !character.animations[animName]) {
                return;
            }
            
            if (character.currentAnimation !== animName || 
                (animName === 'RUN' && character.previousState !== character.isSprinting)) {
                const prevAnim = character.animations[character.currentAnimation];
                const nextAnim = character.animations[animName];
                
                nextAnim.reset().fadeIn(0.2).play();
                nextAnim.timeScale = (animName === 'RUN' && character.isSprinting) ? 1.25 : 1;
                
                if (prevAnim && prevAnim !== nextAnim) {
                    prevAnim.fadeOut(0.2);
                }
                
                character.currentAnimation = animName;
                character.previousState = character.isSprinting;
            }
        }

        // Ground detection with multiple surfaces
        function checkGrounded() {
            const raycaster = new THREE.Raycaster(
                character.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
                new THREE.Vector3(0, -1, 0),
                0,
                characterControls.groundDetectionRayLength
            );
            const intersects = raycaster.intersectObjects([ground, platform, floor]);
            
            character.isGrounded = intersects.length > 0;
            if (character.isGrounded) {
                character.position.y = intersects[0].point.y + characterControls.groundOffset;
            }
            
            return character.isGrounded;
        }

        // Boundary collision detection
        function checkBoundaryCollision(newPosition) {
            // Check if the new position would be outside the boundaries
            if (newPosition.x < boundaries.minX || newPosition.x > boundaries.maxX ||
                newPosition.z < boundaries.minZ || newPosition.z > boundaries.maxZ) {
                return true; // Collision detected
            }
            return false; // No collision
        }

        // Camera positioning
        function updateCameraPosition(initial = false) {
            if (!character.model || !character.isLoaded) {
                return;
            }
            
            if (cameraState.mode === 'orbit') {
                orbitControls.target.copy(character.position.clone().add(new THREE.Vector3(0, characterControls.lookAtHeight, 0)));
                orbitControls.update();
                return;
            }
            
            const idealOffset = new THREE.Vector3(
                0,
                characterControls.cameraHeight,
                characterControls.cameraDistance
            );
            
            idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.rotation.y);
            idealOffset.add(character.position);
            
            if (initial) {
                camera.position.copy(idealOffset);
            } else {
                camera.position.lerp(idealOffset, characterControls.cameraSmoothing);
            }
            
            const lookAtPos = character.position.clone();
            lookAtPos.y += characterControls.lookAtHeight;
            
            camera.lookAt(lookAtPos);
            camera.rotateX(cameraState.rotation.x);
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Camera mode toggle
        window.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                cameraState.mode = cameraState.mode === 'follow' ? 'orbit' : 'follow';
                orbitControls.enabled = cameraState.mode === 'orbit';
                
                if (cameraState.mode === 'orbit') {
                    orbitControls.target.copy(character.position.clone().add(new THREE.Vector3(0, 1, 0)));
                }
            }
        });

        // Model loading button
        document.getElementById('load-models-btn').addEventListener('click', async () => {
            const model1Choice = document.getElementById('model-1-choice').value;
            const model2Choice = document.getElementById('model-2-choice').value;
            const modelStatus = document.getElementById('model-status');
            const loadButton = document.getElementById('load-models-btn');
            
            loadButton.disabled = true;
            modelStatus.textContent = `Loading models...`;
            
            try {
                // Check model 1
                const model1Response = await fetch(`${PYTHON_SERVER_URL}/check-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: model1Choice
                    })
                });
                
                const model1Data = await model1Response.json();
                
                if (model1Data.success) {
                    modelStatus.textContent = `Model 1 loaded. Loading Model 2...`;
                    model1Loaded = true;
                } else {
                    modelStatus.textContent = `Error loading Model 1: ${model1Data.error}`;
                    loadButton.disabled = false;
                    return;
                }
                
                // Check model 2
                const model2Response = await fetch(`${PYTHON_SERVER_URL}/check-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_id: model2Choice
                    })
                });
                
                const model2Data = await model2Response.json();
                
                if (model2Data.success) {
                    modelStatus.textContent = `Both models loaded successfully`;
                    model2Loaded = true;
                    
                    // Start AI instructions once models are loaded
                    if (character.isLoaded && !isLoadingInstructions) {
                        isLoadingInstructions = true;
                        
                        // Get first movement instruction using Model 1
                        aiInstructions = await getAIMovementInstructions(
                            character.position, 
                            character.actionHistory, 
                            hitWall,
                            true // Start with Model 1
                        );
                        
                        isLoadingInstructions = false;
                    }
                } else {
                    modelStatus.textContent = `Error loading Model 2: ${model2Data.error}`;
                }
            } catch (error) {
                modelStatus.textContent = `Connection error: ${error.message}`;
                console.error('Error checking models:', error);
            }
            
            loadButton.disabled = false;
        });

        // Animation loop
        const clock = new THREE.Clock();
        let lastTime = 0;
        
        async function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = clock.getElapsedTime();
            const delta = Math.min(currentTime - lastTime, 0.1);
            lastTime = currentTime;
            
            if (cameraState.mode === 'orbit') {
                orbitControls.update();
            }
            
            if (character.mixer) {
                character.mixer.update(delta);
            }
            
            if (!character.isLoaded || !model1Loaded || !model2Loaded || isLoadingInstructions) {
                renderer.render(scene, camera);
                return;
            }
            
            checkGrounded();
            
            if (!sequenceCompleted && aiInstructions.length > 0) {
                const currentInstruction = aiInstructions[currentInstructionIndex];
                
                if (!currentInstruction || !currentInstruction.action) {
                    instructionTimer = 0;
                    currentInstructionIndex++;
                    return;
                }
                
                instructionTimer += delta;
                
                const progressPercent = (instructionTimer / currentInstruction.duration) * 100;
                document.getElementById('action-progress').style.width = `${Math.min(progressPercent, 100)}%`;
                
                document.getElementById('ai-status').innerHTML = 
                    `<strong>Action:</strong> ${formatActionName(currentInstruction.action)}<br>` +
                    `<strong>Thought:</strong> ${currentInstruction.thought || "..."}<br>` +
                    `<strong>Progress:</strong> ${Math.min(Math.floor(progressPercent), 100)}%`;
                
                character.isMoving = false;
                character.isSprinting = false;
                character.isJumping = false;
                character.isLookingAround = false;
                character.velocity.x = 0;
                character.velocity.z = 0;
                
                // Calculate movement directions
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.rotation.y);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);
                right.normalize();
                
                let moveDirection = new THREE.Vector3();
                
                switch (currentInstruction.action.toLowerCase()) {
                    case 'moveforward':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        break;
                    case 'movebackward':
                        moveDirection.sub(forward);
                        character.isMoving = true;
                        break;
                    case 'moveleft':
                        moveDirection.add(right);
                        character.isMoving = true;
                        break;
                    case 'moveright':
                        moveDirection.sub(right);
                        character.isMoving = true;
                        break;
                    case 'sprint':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        character.isSprinting = true;
                        break;
                    case 'jump':
                        if (character.isGrounded) {
                            character.isJumping = true;
                            character.velocity.y = characterControls.jumpForce;
                        }
                        break;
                    case 'idle':
                        // No movement in idle state
                        break;
                    case 'lookaround':
                        character.isLookingAround = true;
                        // Rotate camera slightly for looking around effect
                        cameraState.rotation.y += Math.sin(currentTime * 0.5) * 0.01;
                        break;
                    case 'explore':
                        moveDirection.add(forward);
                        character.isMoving = true;
                        // Occasionally change direction during exploration
                        if (Math.random() < 0.05) {
                            cameraState.rotation.y += (Math.random() - 0.5) * 0.1;
                        }
                        break;
                    default:
                        console.warn('Unknown action:', currentInstruction.action);
                }
                
                // Update character rotation to match movement direction
                if (character.isMoving && moveDirection.length() > 0) {
                    moveDirection.normalize();
                    character.rotation = Math.atan2(moveDirection.x, moveDirection.z);
                    character.model.rotation.y = character.rotation;
                }
                
                if (character.isMoving) {
                    const speed = characterControls.moveSpeed * 
                        (character.isSprinting ? characterControls.sprintMultiplier : 1) * 
                        (character.isGrounded ? 1 : characterControls.airControl);
                    
                    character.velocity.x = moveDirection.x * speed;
                    character.velocity.z = moveDirection.z * speed;
                } else {
                    character.velocity.x *= characterControls.friction;
                    character.velocity.z *= characterControls.friction;
                }
                
                // Apply gravity and ground constraints
                if (!character.isGrounded) {
                    character.velocity.y -= characterControls.gravity;
                } else if (!character.isJumping) {
                    character.velocity.y = 0;
                }
                
                // Set appropriate animation based on character state
                if (!character.isGrounded && character.velocity.y < 0) {
                    setAnimation('FALL');
                } else if (character.isJumping) {
                    setAnimation('JUMP');
                } else if (character.isMoving) {
                    if (character.isSprinting && character.animations['RUN']) {
                        setAnimation('RUN');
                    } else if (character.animations['WALK']) {
                        setAnimation('WALK');
                    } else if (character.animations['RUN']) {
                        setAnimation('RUN');
                    }
                } else if (character.isLookingAround && character.animations['IDLE_LOOK']) {
                    setAnimation('IDLE_LOOK');
                } else {
                    setAnimation('IDLE');
                }
                
                // Calculate new position with velocity
                const newPosition = character.position.clone().add(character.velocity);
                
                // Check for boundary collisions before applying movement
                if (!checkBoundaryCollision(newPosition)) {
                    // No collision, apply movement
                    character.position.copy(newPosition);
                    hitWall = false;
                } else {
                    // Collision detected, stop movement in that direction
                    // Allow sliding along walls by applying only valid components of velocity
                    hitWall = true;
                    
                    // Try moving only in X direction
                    const newPositionX = character.position.clone();
                    newPositionX.x += character.velocity.x;
                    
                    if (!checkBoundaryCollision(newPositionX)) {
                        character.position.x = newPositionX.x;
                    }
                    
                                        // Try moving only in Z direction
                                        const newPositionZ = character.position.clone();
                    newPositionZ.z += character.velocity.z;
                    
                    if (!checkBoundaryCollision(newPositionZ)) {
                        character.position.z = newPositionZ.z;
                    }
                    
                    // Reset velocity in directions that had collisions
                    if (character.position.x !== newPosition.x) {
                        character.velocity.x = 0;
                    }
                    if (character.position.z !== newPosition.z) {
                        character.velocity.z = 0;
                    }
                }
                
                // Update model position
                character.model.position.copy(character.position);
                
                // Check if current instruction is complete
                if (instructionTimer >= currentInstruction.duration) {
                    character.actionHistory.push({
                        action: currentInstruction.action,
                        thought: currentInstruction.thought,
                        position: {
                            x: character.position.x,
                            y: character.position.y,
                            z: character.position.z
                        },
                        grid: getGridPosition(character.position)
                    });
                    
                    instructionTimer = 0;
                    currentInstructionIndex++;
                    
                    // Reset character state when instruction completes
                    character.isMoving = false;
                    character.isSprinting = false;
                    character.isJumping = false;
                    character.isLookingAround = false;
                    character.velocity.x = 0;
                    character.velocity.z = 0;
                    
                    // Force idle animation between instructions
                    setAnimation('IDLE');
                    
                    // Get new instruction when current one is complete
                    if (currentInstructionIndex >= aiInstructions.length) {
                        isLoadingInstructions = true;
                        document.getElementById('ai-thinking').textContent = "Planning next action...";
                        
                        try {
                            // Toggle between models for each new instruction
                            useModel1 = !useModel1;
                            
                            // Get a single new instruction from the alternate model
                            aiInstructions = await getAIMovementInstructions(
                                character.position, 
                                character.actionHistory,
                                hitWall,
                                useModel1
                            );
                            currentInstructionIndex = 0;
                            instructionTimer = 0;
                        } catch (error) {
                            console.error("Error getting new AI instructions:", error);
                            document.getElementById('ai-thinking').textContent = "Error planning. Using fallback behavior.";
                            aiInstructions = [
                                { action: 'idle', duration: 2, thought: 'Thinking what to do next' }
                            ];
                            currentInstructionIndex = 0;
                        }
                        
                        isLoadingInstructions = false;
                    }
                }
            }
            
            // Update camera position
            updateCameraPosition();
            
            renderer.render(scene, camera);
        }
        
        function formatActionName(action) {
            if (!action) return "Unknown";
            return action
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase());
        }
        
        animate();
    </script>
</body>
</html>
